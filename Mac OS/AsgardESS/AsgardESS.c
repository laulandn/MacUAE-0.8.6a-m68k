//=================================================================================================////		The Asgard Emulator Sound System for the Macintosh////		A free sound library for high-precision reproduction of emulated sound.////		Written by Aaron Giles//		Version 1.2 -- March 24, 1998////=================================================================================================////		What is it?//			The Asgard Emulator Sound System is a low-latency, high-precision sound library geared //			toward providing a simple sound interface for Macintosh emulator authors.////		Why does it exist?//			Because the type of sound processing needed for accurate emulation of earlier-generation//			sound hardware is not a trivial exercise on the Macintosh.////		How can I use it?//			Easy -- the Asgard Emulator Sound System is almost totally free, so you can include it //			in your emulation project -- freeware, shareware, or commercial -- without any legal//			or licensing hassles.////		What do you mean by "almost totally free"?//			All I ask that if you do make use of this code that you give me appropriate credit in //			your about box and documentation, and that you send me a free copy of any products you//			release which make use of the Asgard Emulator Sound System.////		Where do I contact you?//			If you are having any trouble with the library, or need some assistance, feel free to//			send me email: agiles@sirius.com.  If you need a shipping address, contact me via email //			first and I'll give it to you.////=================================================================================================#define AESS_DEBUG 0//=================================================================================================//		Include files//=================================================================================================// Macintosh headers#include <Memory.h>#include <OSUtils.h>#include <Sound.h>#include <Timer.h>// standard C headers, for debugging only#if AESS_DEBUG#include <stdio.h>#include <stdarg.h>#endif#include <stdlib.h>// local headers#include "AsgardESS.h"#include <string.h>//=================================================================================================//		Constants//=================================================================================================// the number of buffered sound commands and mask to and the values with#define BUFFER_LIST_ENTRIES 	1024#define BUFFER_LIST_MASK 		(BUFFER_LIST_ENTRIES - 1)// built-in buffered sound latency and threshhold#define BASE_LATENCY				10000			/* deliberately stay behind an extra 10 ms */#define MIN_LATENCY				2500			/* try not to let it get less than 2.5 ms */#define MAX_LATENCY				17500			/* try not to let it get greater than 17.5 ms */// how many extra buffer sizes we should have for streamed data (too big and latency can be a problem)#define STREAM_MULT				3// bits of accuracy in the scaled volume#define VOLUME_BITS				4// bits of accuracy in the fixed point fraction (must be at least 16)#define FRAC_BITS					24#define FRAC_ONE					(1L << 24)#define FRAC_MASK					(FRAC_ONE - 1)// how many samples to generate per callback at 44kHz#define SAMPLE_FRAMES_44kHz	2048// enumeration of the types of voicesenum{	kVoiceKindInactive = 0,	kVoiceKindStreamed,	kVoiceKindBuffered,	kVoiceKindBuffered16,	kVoiceKindManual,	kVoiceKindManual16};//=================================================================================================//		Structures & Typedefs//=================================================================================================// a mixer functiontypedef void (*AsgardESS_Mixer)(struct SoundGlobals *pSound, struct VoiceInfo *pVoice, unsigned long time);// a single buffered sampletypedef struct BufferedSample{	unsigned long				time;						// start time, low 32 bits of microseconds	unsigned long				length;					// length of sample, 20.12 fixed point bytes	void *						pSample;					// pointer to the sample data, 8-bit signed	long							frequency;				// frequency, in Hz	short							volume;					// current volume, 0-255	short							loop;						// loop flag, TRUE/FALSE} BufferedSample;// a single manually buffered sampletypedef struct ManualSample{	unsigned long				time;						// start time, low 32 bits of microseconds	unsigned char				userData[];				// start of user data} ManualSample;// the data associated with a buffered sound voicetypedef struct BufferData{	BufferedSample *			pList;					// pointer to circular list of samples	BufferedSample				last;						// copy of the last sample added	long							lastFrequency;			// the frequency of the last sample, in Hz	unsigned long				pos;						// last position in sample	unsigned long				frac;						// last fractional position in sample	short							in;						// list index for incoming samples	short							out;						// list index for outgoing samples	long							lastSample;				// last sample we used (for interpolation)	short							playing;					// is the sample still playing?	long							multiplier;				// used for waveform playback} BufferData;// the data associated with a streamed sound voicetypedef struct StreamData{   long *						pBuffer;					// pointer to pre-downsampled mix buffer	unsigned long				size;						// size of the data buffer	unsigned long				pos;						// last position in sample	unsigned long				frac;						// last fractional position in sample	unsigned long				in;						// offset of incoming data	unsigned long				out;						// offset of outgoing data} StreamData;// the data associated with a manually buffered voicetypedef struct ManualData{	ManualSample *				pList;					// array of pointers to application-specific data	ManualSample *				pLast;					// pointer to the last update we sent to the callback	long							dataSize;				// size of the application-specific data	unsigned char *			pBuffer;					// pointer to temporary generation buffer	unsigned long				size;						// size of the data buffer	unsigned long				frequency;				// playback frequency, in Hz	unsigned long				frac;						// fractional last position in sample	short							volume;					// current volume, 0-255	short							in;						// list index for incoming samples	short							out;						// list index for outgoing samples	short							leftOvers;				// number of leftover samples in the buffer	void *						pCallback;				// callback function to generate samples	void *						pUserData;				// pointer to the user data} ManualData;// the data associated with a specific voicetypedef struct VoiceInfo{	short							ready;					// ready flag, TRUE/FALSE	short							kind;						// which kind of voice is it?	AsgardESS_Mixer			mixer;					// which mixer to use	union	{		BufferData				buffer;					// data for buffered voices		StreamData				stream;					// data for streamed voices		ManualData				manual;					// data for manual voices	} data;} VoiceInfo;// the global sound data needed by AsgardESStypedef struct SoundGlobals{	// general parameters	long							frequency;				// the output frequency, in Hz	int							sixteenBit;				// 16-bit output?	int							voices;					// number of voices	int							gain;						// the current output gain	int							mixer;					// the current output mixer	int							interpolated;			// interpolated or not?	int							normalized;				// normalized or not?	unsigned char				normalizedXor;			// XOR value for normalization	// remembering old sound status	long							originalVolume;		// original master volume	int							originalValid;			// original volume valid?	// double-buffering parameters	long							doubleBufferFrames;	// double buffer size, in frames	long							doubleBufferSize;		// double buffer size, in bytes	// timing and latency computations	unsigned long				usecsPerCallback;		// number of microseconds per callback	unsigned long				computedTime;			// the currently calculated time	long							minLatency;				// the lowest latency we've seen recently	unsigned long				callbackCount;			// number of times we've been called back	unsigned long				resetCount;				// the count at our last reset	// voice information	VoiceInfo *					pVoice;					// array of voice-specific data	// Sound Manager information	SndChannelPtr  			pChannel;            // pointer to the sound channel	SndDoubleBufferHeader 	dbHeader;     			// the double buffer header	// buffers and tables	long *						pMixBuffer;				// mixing buffer	void *						pMixerTable;			// mixer table	void *						pMixerMiddle;			// middle of the mixer table	// sound state information	int		        			soundPaused;         // is all sound pased?	int		        			soundEnd;            // signal for double-buffering	int		        			soundActive;         // is all sound active?	// sample data (8-bit)	unsigned char				silentSample[1];		// 1-byte silent sample	unsigned char				squareSample[2];		// 2-byte square wave sample	unsigned char				noiseSample[1024];	// 1024-byte noise sample	// sample data (16-bit)	short							silentSample16[1];	// 1-word silent sample	short							squareSample16[2];	// 2-word square wave sample	short							noiseSample16[1024];	// 1024-word noise sample} SoundGlobals;//=================================================================================================//		Static globals//=================================================================================================static SoundGlobals gSound;static SndDoubleBackUPP pDoubleBack = nil;#if !GENERATINGCFMstatic ProcPtr pOldExitToShell = nil;#endif#if AESS_DEBUG#define DEBUG_BUFFER 500000static char debugbuf[DEBUG_BUFFER];static long debugindex;#endif//=================================================================================================//		Local function Prototypes//=================================================================================================// memory utilitiesstatic void *			AsgardESS_Malloc						(long size);static void				AsgardESS_Free							(void *pMemory);static void 			AsgardESS_Set 							(void *pData, unsigned char val, long count);// OS utilities#if !GENERATINGCFMstatic void 			AsgardESS_PatchExitToShell 		(void);static void 			AsgardESS_ExitToShell 				(void);static void				AsgardESS_RememberA5					(void);#endif// table generationstatic void 			AsgardESS_MakeMixerTable 			(int sixteenBit);static void 			AsgardESS_GenerateTables 			(void);// low-level sound mixersstatic unsigned long AsgardESS_ComputeSoundInterval 	(SoundGlobals *pSound);static void 			AsgardESS_MixStreamedSound 		(SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long time);static void 			AsgardESS_MixBufferedSound 		(SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long time);static void 			AsgardESS_MixBufferedSound16 		(SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long time);static void 			AsgardESS_MixManualSound 			(SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long time);static void 			AsgardESS_MixManualSound16			(SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long time);// sound manager interfacestatic OSErr 			AsgardESS_DoubleBackStart 			(void);static void 			AsgardESS_DoubleBackStop 			(void);static pascal void 	AsgardESS_DoubleBack 				(SndChannelPtr channel, SndDoubleBufferPtr doubleBufferPtr);// debugging utilities#if AESS_DEBUGvoid						AsgardESS_DebugLog					(char *fmt, ...);#endif#pragma mark ==================== Inline Functions//=================================================================================================////		Optimized inline functions////=================================================================================================#if GENERATINGPOWERPC	// NOTE: inline in C code requires CW11 or later....	// optimized inline long setting	inline void aess_SetLongs (void *pData, unsigned long val, long count)	{		unsigned long *pDest = (void *)pData;		int i;		for (i = 0, --pDest; i < count; i++)			*++pDest = val;	}	// optimized inline mix to 16 bit code	inline void aess_MixTo16Bit (long *pMix, short *pDst, short *pMixDown, int count)	{		int i;		pDst--, pMix--;		for (i = 0; i < count; i++)			*++pDst = pMixDown[*++pMix >> 4];	}	// optimized inline mix to 8 bit code	inline void aess_MixTo8Bit (long *pMix, unsigned char *pDst, unsigned char *pMixDown, int count)	{		int i;		pDst--, pMix--;		for (i = 0; i < count; i++)			*++pDst = pMixDown[*++pMix >> 4];	}		// optimized inline mix to linear 16 bit code	inline void aess_MixTo16BitLinear (long *pMix, short *pDst, int count)	{		int i;		pDst--, pMix--;		for (i = 0; i < count; i++)		{			long val = *++pMix;			if (val < -32768) val = -32768;			else if (val > 32767) val = 32767;			*++pDst = val;		}	}	// optimized inline mix to linear 8 bit code	inline void aess_MixTo8BitLinear (long *pMix, unsigned char *pDst, int count)	{		int i;		pDst--, pMix--;		for (i = 0; i < count; i++)		{			long val = *++pMix >> 8;			if (val < -128) val = -128;			else if (val > 127) val = 127;			*++pDst = val + 0x80;		}	}		// high-precision divide to a fixed point result	inline unsigned long aess_ShiftAndDivide (unsigned long num, unsigned long denom, unsigned long shift)	{		return (unsigned long)((double)num / (double)denom * (double)(1 << shift));	}		// interpolation - we use 14 bits of the fraction to allow for some overflow of the sample	inline long aess_Interpolate (long samp1, long samp2, long frac)	{		frac >>= (FRAC_BITS - 14);		return (samp1 * (0x4000 - frac) + samp2 * frac) >> 14;	}#else	// optimized inline long setting	void aess_SetLongs (void *pData:__A0, unsigned long val:__D0, long count:__D1) = 		{			0x5381,              // subq.l    #1,d1			0x20C0,              // move.l    d0,(a0)+			0x51C9,0xFFFC        // dbra      d1,*-2		};	// optimized inline mix to 16 bit code	void aess_MixTo16Bit (long *pMix:__A0, short *pDst:__A1, short *pMixDown:__D2, int count:__D0) =		{			0xC58A,					// exg       d2,a2			0x2218,					// move.l    (a0)+,d1			0xE881,					// asr.l     #4,d1			0x32F2,0x1A00,			// move.w    (a2,d1.l*2),(a1)+			0x51C8,0xFFF6,			// dbra      d0,*-8			0xC58A					// exg       d2,a2		};	// optimized inline mix to 8 bit code	void aess_MixTo8Bit (long *pMix:__A0, unsigned char *pDst:__A1, unsigned char *pMixDown:__D2, int count:__D0) =		{			0xC58A,              // exg       d2,a2			0x2218,              // move.l    (a0)+,d1			0xE881,              // asr.l     #4,d1			0x12F2,0x1800,       // move.b    (a2,d1.l),(a1)+			0x51C8,0xFFF6,       // dbra      d0,*-8			0xC58A               // exg       d2,a2		};	// optimized inline mix to linear 16 bit code	void aess_MixTo16BitLinear (long *pMix:__A0, short *pDst:__A1, int count:__D0) =		{			0x2F03,              // move.l    d3,-(a7)			0x243C,0xFFFF,0x8000,// move.l    #-32768,d2			0x263C,0x0000,0x7FFF,// move.l    #32767,d3			0x2218,              // move.l    (a0)+,d1			0xB282,              // cmp.l     d2,d1			0x6C04,              // bge.s     *+6			0x2202,              // move.l    d2,d1			0x6006,              // bra.s     *+8			0xB283,              // cmp.l     d3,d1			0x6F02,              // ble.s     *+4			0x2203,              // move.l    d3,d1			0x32C1,              // move.w    d1,(a1)+			0x51C8,0xFFEC,       // dbra      d0,*-18			0x261F               // move.l    (a7)+,d3		};			// optimized inline mix to linear 8 bit code	void aess_MixTo8BitLinear (long *pMix:__A0, unsigned char *pDst:__A1, int count:__D0) =		{			0x2F03,              // move.l    d3,-(a7)			0x243C,0xFFFF,0xFF80,// move.l    #-128,d2			0x263C,0x0000,0x007F,// move.l    #127,d3			0x2218,              // move.l    (a0)+,d1			0xE081,              // asr.l     #8,d1			0xB282,              // cmp.l     d2,d1			0x6C04,              // bge.s     *+6			0x2202,              // move.l    d2,d1			0x6006,              // bra.s     *+8			0xB283,              // cmp.l     d3,d1			0x6F02,              // ble.s     *+4			0x2203,              // move.l    d3,d1			0xD202,              // add.b     d2,d1			0x12C1,              // move.b    d1,(a1)+			0x51C8,0xFFE8,       // dbra      d0,*-22			0x261F               // move.l    (a7)+,d3		};	// high-precision divide to a fixed point result	unsigned long aess_ShiftAndDivide (unsigned long num:__D0, unsigned long denom:__D1, unsigned long shift:__D2):__D0 =		{			0x2041,					// movea.l   d1,a0			0x2200,              // move.l    d0,d1			0xE5A8,              // lsl.l     d2,d0			0x4402,              // neg.b     d2			0xD43C,0x0020,       // add.b     #$20,d2        ; ' '			0xE4A9,              // lsr.l     d2,d1			0x2408,              // move.l    a0,d2			0x4C42,0x0401        // divu.l    d2,d1:d0		};	// interpolation - we use 14 bits of the fraction to allow for some overflow of the sample	#if (FRAC_BITS == 24)	int aess_Interpolate (int samp1:__D0, int samp2:__D1, unsigned long frac:__D2):__D0 =		{			0xEA8A,              // lsr.l     #5,d2			0xEA8A,              // lsr.l     #5,d2			0x4C02,0x1801,       // muls.l    d2,d1			0x4642,              // not.w     d2			0x0242,0x3FFF,       // andi.w    #0x3fff,d2			0x4C02,0x0800,       // muls.l    d2,d0			0xD081,              // add.l     d1,d0			0xEE80,              // asr.l     #7,d0			0xEE80               // asr.l     #7,d0		};	#else	#error Need to rewrite aess_Interpolate for new value of FRAC_BITS bits	#endif#endif#pragma mark ==================== Initialization/Termination//=================================================================================================////		AsgardESS_Init////		Initializes the sound library, creating the sound channel and allocating all memory////=================================================================================================////		Inputs://			frequency = the output frequency, in Hz. A good value for PowerPC's is 44100; it's//						probably best to use something smaller for 68k machines, like 22050.////			voices = the number of simultaneous voices. All voices are mixed on the fly into//						a single sound stream.////			sixteenBit = controls 16-bit output. Even though all incoming samples must be 8-bit,//						mixing the final output to 16 bits gives better volume resolution and less//						noise. Note that AsgardESS does not verify that a given system supports//						16-bit sound, so you must check on your own.////			interpolate = controls linear interpolation between samples during frequency scaling. //						Turning this on results in a sound system that is more accurate, but more //						time consuming to operate.////			normalized = indicates whether the incoming 8-bit samples are normalized. Normalized//						samples have their 0 point at 0x80, with the minimum value = 0x00, and the//						maximum value 0xff. Non-normalized samples are treated as signed chars, with//						a zero point at 0x00, a minimum at 0x80 (-128), and a maximum at 0x7f (+127).////		Returns://			a standard MacOS error code; noErr indicates success////=================================================================================================OSErr AsgardESS_Init (long frequency, int voices, int sixteenBit, int interpolate, int normalized, int mixer, int gain){	OSErr err;	int i;		// some sanity checking	if (frequency < 1000 || frequency > 44100)		return false;	if (voices < 1 || voices > 16)		return false;		// set up the UPP if we haven't already	if (!pDoubleBack)		pDoubleBack = NewSndDoubleBackProc (AsgardESS_DoubleBack);			// allocate the voice information array	gSound.pVoice = AsgardESS_Malloc (voices * sizeof (VoiceInfo));	if (!gSound.pVoice)	{		err = MemError ();		goto error;	}		// allocate the two double buffers	for (i = 0; i < 2; i++)	{		gSound.dbHeader.dbhBufferPtr[i] = AsgardESS_Malloc (SAMPLE_FRAMES_44kHz * sizeof (short) + sizeof (SndDoubleBuffer));		if (!gSound.dbHeader.dbhBufferPtr[i])		{			err = MemError ();			goto error;		}	}	// allocate the mixing buffer	gSound.pMixBuffer = AsgardESS_Malloc (SAMPLE_FRAMES_44kHz * sizeof (long));	if (!gSound.pMixBuffer)	{		err = MemError ();		goto error;	}	// allocate the mixer table -- big enough for 16-bit even if we're not using it all	gSound.pMixerTable = AsgardESS_Malloc (voices * 256 * 16 * sizeof (short));	if (!gSound.pMixerTable)	{		err = MemError ();		goto error;	}	// get the default volume	GetDefaultOutputVolume (&gSound.originalVolume);	gSound.originalValid = true;			// fill in the basic data	gSound.frequency = frequency;	gSound.voices = voices;	gSound.gain = gain;	gSound.mixer = mixer;	gSound.sixteenBit = sixteenBit;	gSound.interpolated = interpolate;	gSound.normalized = normalized;	gSound.normalizedXor = normalized ? 0x80 : 0x00;	gSound.soundPaused = false;	// regenerate tables and samples	AsgardESS_GenerateTables ();		// start the double-buffered playback	err = AsgardESS_DoubleBackStart ();	if (err != noErr)		goto error;		// mark the system active	return noErr;error:	AsgardESS_Term ();	return err;}//=================================================================================================////		AsgardESS_ResetVoice////		Resets the state of the voice, freeing all memory and making it available for another use////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////=================================================================================================void AsgardESS_ResetVoice (int voice){	VoiceInfo *pVoice;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return;	pVoice = gSound.pVoice + voice;	// mark the voice not ready	pVoice->ready = false;	// kill buffered voice-specific data	if (pVoice->kind == kVoiceKindBuffered)	{		if (pVoice->data.buffer.pList)			AsgardESS_Free (pVoice->data.buffer.pList);	}		// kill streamed voice-specific data	else if (pVoice->kind == kVoiceKindStreamed)	{		if (pVoice->data.stream.pBuffer)			AsgardESS_Free (pVoice->data.stream.pBuffer);	}		// kill manual voice-specific data	else if (pVoice->kind == kVoiceKindManual || pVoice->kind == kVoiceKindManual16)	{		if (pVoice->data.manual.pBuffer)			AsgardESS_Free (pVoice->data.manual.pBuffer);		if (pVoice->data.manual.pList)			AsgardESS_Free (pVoice->data.manual.pList);	}		// zap the voice structure	AsgardESS_Set (pVoice, 0, sizeof (VoiceInfo));}//=================================================================================================////		AsgardESS_Term////		Shuts down the sound library and frees all memory////=================================================================================================void AsgardESS_Term (void){	int i;		// wait for the double buffering to end naturally	AsgardESS_DoubleBackStop ();		// free the mixer table	if (gSound.pMixerTable)		AsgardESS_Free (gSound.pMixerTable);		// free the mix buffer	if (gSound.pMixBuffer)		AsgardESS_Free (gSound.pMixBuffer);		// kill the double buffers	for (i = 0; i < 2; i++)	{		if (gSound.dbHeader.dbhBufferPtr[i])			AsgardESS_Free (gSound.dbHeader.dbhBufferPtr[i]);	}	// now we can dispose of the voice-specific data	if (gSound.pVoice)	{		for (i = 0; i < gSound.voices; i++)			AsgardESS_ResetVoice (i);			// kill the voice data itself		AsgardESS_Free (gSound.pVoice);	}	// restore the default volume	if (gSound.originalValid)		SetDefaultOutputVolume (gSound.originalVolume);			// zap the entire data structure	AsgardESS_Set (&gSound, 0, sizeof (gSound));#if AESS_DEBUG	if (debugindex)	{		FILE *pFile = fopen ("AsgardESS.log", "wt");		if (pFile)		{			fwrite (debugbuf, 1, debugindex, pFile);			fclose (pFile);		}	}#endif}#pragma mark ==================== Sound Output Control//=================================================================================================////		AsgardESS_Pause////		Pauses/resumes any sound playback instantly////=================================================================================================////		Inputs://			paused = true to go into a paused state, or false to resume playing.////		Returns://			the previous paused state (true if paused, false if not paused).////=================================================================================================int AsgardESS_Pause (int pause){	int old = gSound.soundPaused;	// bail if the sound isn't active	if (!gSound.soundActive)		return old;	// do nothing if it's the same	if (pause == gSound.soundPaused)		return old;		// change the state	gSound.soundPaused = pause;	return old;}//=================================================================================================////		AsgardESS_SetFrequency////		Adjust the global output frequency////=================================================================================================////		Inputs://			frequency = the new output frequency, in Hz.////		Returns://			the previous output frequency.////=================================================================================================long AsgardESS_SetFrequency (long frequency){	long old = gSound.frequency;		// fail if it's invalid	if (frequency < 1000 || frequency > 44100)		return old;		// do nothing if it's the same	if (frequency == old)		return old;		// bring down the sound channel	AsgardESS_DoubleBackStop ();		// change the frequency	gSound.frequency = frequency;	// regenerate tables and samples	AsgardESS_GenerateTables ();	// bring it back up	AsgardESS_DoubleBackStart ();		return old;}//=================================================================================================////		AsgardESS_SetSampleSize////		Set the output sample size////=================================================================================================////		Inputs://			sixteenBit = true to output using 16-bit samples, or false to use 8-bit samples.////		Returns://			the previous sample size (true if 16-bit or false if 8-bit).////=================================================================================================int AsgardESS_SetSampleSize (int sixteenBit){	int old = gSound.sixteenBit;	// bail if the sound isn't active	if (!gSound.soundActive)		return old;		// do nothing if it's the same	if (sixteenBit == gSound.sixteenBit)		return old;		// bring down the sound channel	AsgardESS_DoubleBackStop ();		// change the state	gSound.sixteenBit = sixteenBit;		// regenerate tables and samples	AsgardESS_GenerateTables ();	// bring it back up	AsgardESS_DoubleBackStart ();		return old;}//=================================================================================================////		AsgardESS_SetInterpolated////		Turns on/off linear interpolation of sound samples////=================================================================================================////		Inputs://			interpolated = true to enable interpolation, or false to stop interpolating.////		Returns://			the previous interpolation state (true if interpolating, false if not interpolating).////=================================================================================================int AsgardESS_SetInterpolated (int interpolated){	int old = gSound.interpolated;	// bail if the sound isn't active	if (!gSound.soundActive)		return old;	// do nothing if it's the same	if (interpolated == gSound.interpolated)		return old;		// change the state	gSound.interpolated = interpolated;	return old;}//=================================================================================================////		AsgardESS_SetNormalized////		Turns on/off the normalization state of source samples////=================================================================================================////		Inputs://			normalized = true to assume source samples are normalized, or false normalize on the fly.////		Returns://			the previous normalization state (true if normalized, false if not normalized).////=================================================================================================int AsgardESS_SetNormalized (int normalized){	int old = gSound.normalized;	// bail if the sound isn't active	if (!gSound.soundActive)		return old;	// do nothing if it's the same	if (normalized == gSound.normalized)		return old;		// change the state	gSound.normalized = normalized;	gSound.normalizedXor = normalized ? 0x80 : 0x00;	return old;}//=================================================================================================////		AsgardESS_SetGain////		Sets the ////=================================================================================================////		Inputs://			normalized = true to assume source samples are normalized, or false normalize on the fly.////		Returns://			the previous normalization state (true if normalized, false if not normalized).////=================================================================================================int AsgardESS_SetGain (int gain){	int old = gSound.gain;	// bail if the sound isn't active	if (!gSound.soundActive)		return old;	// do nothing if it's the same	if (gain == gSound.gain)		return old;		// set the new gain	gSound.gain = gain;	return old;}//=================================================================================================////		AsgardESS_SetMixer////		Set the output mixer function////=================================================================================================////		Inputs://			mixer = index of which mixer to use.////		Returns://			the previous mixer index.////=================================================================================================int AsgardESS_SetMixer (int mixer){	int old = gSound.mixer;	// bail if the sound isn't active	if (!gSound.soundActive)		return old;		// do nothing if it's the same	if (mixer == gSound.mixer)		return old;		// change the state	gSound.mixer = mixer;		return old;}//=================================================================================================////		AsgardESS_SetMasterVolume////		Sets the global system volume to the specified value////=================================================================================================////		Inputs://			newVolume = the new volume, from 0 to 255.////		Returns://			the previous volume.////=================================================================================================int AsgardESS_SetMasterVolume (int newVolume){	long old;		// get the old volume	GetDefaultOutputVolume (&old);	old &= 0xffff;		// set the new volume	SetDefaultOutputVolume ((newVolume << 16) + newVolume);		return old;}#pragma mark ==================== Buffered Sample Playing//=================================================================================================////		AsgardESS_PlaySample////		Begins playing a new sample on the given voice////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			pData = a pointer to the sampled 8-bit sound data////			length = the length of the sampled sound data, in bytes.////			frequency = the frequency to play the sample at, in Hz. Note that this is completely//						independent of the frequency specified to AsgardESS_Init. The sound sample//						will be converted on the fly to the output frequency.////			volume = the volume to play the sample at, from 0 (off) to 255 (max).////			loop = true to loop the sample indefinitely, or false to stop after one loop through.////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================////		Notes://			Samples played via this function are merely recorded with a timestamp and processed//			at interrupt time in the Sound Manager double back routine.  This means that//			interrupt-time processing can be more significant.  It also means that if you are//			not emulating sound as quickly as the original machine, it will merely play slowly,//			rather than producing gaps as you would get with play streamed sample, below.////=================================================================================================int AsgardESS_PlaySample (int voice, unsigned char *pData, long length, long frequency, int volume, int loop){	BufferedSample *pSample;	UnsignedWide time;	VoiceInfo *pVoice;	int next;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;	// bail on an invalid length			if (length <= 0)		return false;	// if we have no double-buffering for this channel yet, crank it up	if (pVoice->kind == kVoiceKindInactive)	{		// allocate space for the sample list		pVoice->data.buffer.pList = AsgardESS_Malloc (BUFFER_LIST_ENTRIES * sizeof (BufferedSample));		if (!pVoice->data.buffer.pList)			return false;				// set the kind to activate it		pVoice->kind = kVoiceKindBuffered;		pVoice->mixer = AsgardESS_MixBufferedSound;				// multiplier is 1 by default		pVoice->data.buffer.multiplier = 1;	}	// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindBuffered)		return false;	// determine where to add the sample	pSample = pVoice->data.buffer.pList + pVoice->data.buffer.in;	next = (pVoice->data.buffer.in + 1) & BUFFER_LIST_MASK;		// if we've wrapped around, bail	if (next == pVoice->data.buffer.out)		return false;		// fill in the data for this sample	Microseconds (&time);	pSample->time       = time.lo;	pSample->frequency  = (frequency != -1) ? frequency : pVoice->data.buffer.last.frequency;	pSample->pSample    = (pData) ? pData : pVoice->data.buffer.last.pSample;	pSample->length     = (pData) ? length : pVoice->data.buffer.last.length;	pSample->volume     = (volume != -1) ? volume : pVoice->data.buffer.last.volume;	pSample->loop       = (pData) ? loop : pVoice->data.buffer.last.loop;		// remember this entry as the last sample we did	pVoice->data.buffer.last = *pSample;	if (frequency != -1)		pVoice->data.buffer.lastFrequency = frequency;		// advance the incoming pointer and announce we're ready	pVoice->data.buffer.in = next;	pVoice->data.buffer.playing = true;	pVoice->ready = true;		return true;}//=================================================================================================////		AsgardESS_PlaySample16////		16-bit version of the above////=================================================================================================int AsgardESS_PlaySample16 (int voice, short *pData, long length, long frequency, int volume, int loop){	BufferedSample *pSample;	UnsignedWide time;	VoiceInfo *pVoice;	int next;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;	// bail on an invalid length			if (length <= 0)		return false;	// if we have no double-buffering for this channel yet, crank it up	if (pVoice->kind == kVoiceKindInactive)	{		// allocate space for the sample list		pVoice->data.buffer.pList = AsgardESS_Malloc (BUFFER_LIST_ENTRIES * sizeof (BufferedSample));		if (!pVoice->data.buffer.pList)			return false;				// set the kind to activate it		pVoice->kind = kVoiceKindBuffered16;		pVoice->mixer = AsgardESS_MixBufferedSound16;				// multiplier is 1 by default		pVoice->data.buffer.multiplier = 1;	}	// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindBuffered16)		return false;	// determine where to add the sample	pSample = pVoice->data.buffer.pList + pVoice->data.buffer.in;	next = (pVoice->data.buffer.in + 1) & BUFFER_LIST_MASK;		// if we've wrapped around, bail	if (next == pVoice->data.buffer.out)		return false;		// fill in the data for this sample	Microseconds (&time);	pSample->time       = time.lo;	pSample->frequency  = (frequency != -1) ? frequency : pVoice->data.buffer.last.frequency;	pSample->pSample    = (pData) ? (unsigned char *)pData : pVoice->data.buffer.last.pSample;	pSample->length     = (pData) ? length : pVoice->data.buffer.last.length;	pSample->volume     = (volume != -1) ? volume : pVoice->data.buffer.last.volume;	pSample->loop       = (pData) ? loop : pVoice->data.buffer.last.loop;		// remember this entry as the last sample we did	pVoice->data.buffer.last = *pSample;	if (frequency != -1)		pVoice->data.buffer.lastFrequency = frequency;		// advance the incoming pointer and announce we're ready	pVoice->data.buffer.in = next;	pVoice->data.buffer.playing = true;	pVoice->ready = true;		return true;}//=================================================================================================////		AsgardESS_SetSampleFrequency////		Adjusts the frequency of the sample currently playing on a voice on the fly////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			frequency = the frequency to play the sample at, in Hz. Note that this is completely//						independent of the frequency specified to AsgardESS_Init. The sound sample//						will be converted on the fly to the output frequency.////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================int AsgardESS_SetSampleFrequency (int voice, long frequency){	VoiceInfo *pVoice;	// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;		// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindBuffered && pVoice->kind != kVoiceKindBuffered16)		return false;		// bail if this is a no-op	if (pVoice->data.buffer.lastFrequency == frequency)		return true;	// replay the last sample, but differently	if (pVoice->ready && pVoice->data.buffer.playing)	{		if (pVoice->kind == kVoiceKindBuffered)			return AsgardESS_PlaySample (voice, NULL, 1, frequency, -1, 0);		else			return AsgardESS_PlaySample16 (voice, NULL, 1, frequency, -1, 0);	}		return false;}//=================================================================================================////		AsgardESS_SetSampleVolume////		Adjusts the frequency of the sample currently playing on a voice on the fly////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			volume = the volume to play the sample at, from 0 (off) to 255 (max).////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================int AsgardESS_SetSampleVolume (int voice, int volume){	VoiceInfo *pVoice;	// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;		// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindBuffered && pVoice->kind != kVoiceKindBuffered16)		return false;	// bail if this is a no-op	if (pVoice->data.buffer.last.volume == volume)		return true;	// replay the last sample, but differently	if (pVoice->ready && pVoice->data.buffer.playing)	{		if (pVoice->kind == kVoiceKindBuffered)			return AsgardESS_PlaySample (voice, NULL, 1, -1, volume, 0);		else			return AsgardESS_PlaySample16 (voice, NULL, 1, -1, volume, 0);	}		return false;}//=================================================================================================////		AsgardESS_StopSample////		Halts playback of the current sample////=================================================================================================////		Inputs://			voice = the voice to stop playing on.////=================================================================================================void AsgardESS_StopSample (int voice){	VoiceInfo *pVoice;	// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return;	pVoice = gSound.pVoice + voice;		// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindBuffered && pVoice->kind != kVoiceKindBuffered16)		return;	// play the silent sample infinitely	if (pVoice->kind == kVoiceKindBuffered)		AsgardESS_PlaySample (voice, gSound.silentSample, 1, 0, 0, 1);	else		AsgardESS_PlaySample16 (voice, gSound.silentSample16, 1, 0, 0, 1);	pVoice->data.buffer.playing = false;}//=================================================================================================////		AsgardESS_SamplePlaying////		Returns true if a sample is still playing on the given voice////=================================================================================================////		Inputs://			voice = the voice to check.////=================================================================================================int AsgardESS_SamplePlaying (int voice){	VoiceInfo *pVoice;	// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;		// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindBuffered && pVoice->kind != kVoiceKindBuffered16)		return false;	// return the result	return pVoice->data.buffer.playing;}#pragma mark ==================== Waveform Playing//=================================================================================================////		AsgardESS_PlayWaveform////		Begins playing a new waveform sample on the given voice////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			pData = a pointer to the sampled 8-bit sound data, or one of the following constants:////						SQUARE_WAVE_SAMPLE = a simple square wave sample//						NOISE_SAMPLE = a simple random noise sample////			length = the length of the sampled sound data, in bytes.////			frequency = the frequency to play the sample at, in Hz. Note that this is completely//						independent of the frequency specified to AsgardESS_Init. The sound sample//						will be converted on the fly to the output frequency.////			volume = the volume to play the sample at, from 0 (off) to 255 (max).////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================////		Notes://			Samples played via this function are merely recorded with a timestamp and processed//			at interrupt time in the Sound Manager double back routine.  This means that//			interrupt-time processing can be more significant.  It also means that if you are//			not emulating sound as quickly as the original machine, it will merely play slowly,//			rather than producing gaps as you would get with play streamed sample, below.////=================================================================================================int AsgardESS_PlayWaveform (int voice, unsigned char *pData, long length, long frequency, int volume){	long multiplier = length;	int result;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	// tweak special input parameters	if (pData == AESS_SQUARE_WAVE_SAMPLE)		pData = gSound.squareSample, length = multiplier = sizeof (gSound.squareSample);	else if (pData == AESS_NOISE_SAMPLE)		pData = gSound.noiseSample, length = sizeof (gSound.noiseSample), multiplier = 2;	// otherwise, it's just like play sample	result = AsgardESS_PlaySample (voice, pData, length, frequency * multiplier, volume, true);		// adjust the multiplier	if (result)	{		VoiceInfo *pVoice = gSound.pVoice + voice;		pVoice->data.buffer.multiplier = multiplier;	}		return result;}//=================================================================================================////		AsgardESS_PlayWaveform16////		16-bit version of the above////=================================================================================================int AsgardESS_PlayWaveform16 (int voice, short *pData, long length, long frequency, int volume){	long multiplier = length;	int result;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	// tweak special input parameters	if (pData == AESS_SQUARE_WAVE_SAMPLE)		pData = gSound.squareSample16, length = multiplier = sizeof (gSound.squareSample);	else if (pData == AESS_NOISE_SAMPLE)		pData = gSound.noiseSample16, length = sizeof (gSound.noiseSample), multiplier = 2;	// otherwise, it's just like play sample	result = AsgardESS_PlaySample16 (voice, pData, length, frequency * multiplier, volume, true);		// adjust the multiplier	if (result)	{		VoiceInfo *pVoice = gSound.pVoice + voice;		pVoice->data.buffer.multiplier = multiplier;	}		return result;}//=================================================================================================////		AsgardESS_SetWaveformFrequency////		Adjusts the frequency of the waveform sample currently playing on a voice on the fly////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			frequency = the frequency to play the sample at, in Hz. Note that this is completely//						independent of the frequency specified to AsgardESS_Init. The sound sample//						will be converted on the fly to the output frequency.////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================int AsgardESS_SetWaveformFrequency (int voice, long frequency){	VoiceInfo *pVoice;	// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;		return AsgardESS_SetSampleFrequency (voice, frequency * pVoice->data.buffer.multiplier);}//=================================================================================================////		AsgardESS_SetWaveformVolume////		Adjusts the frequency of the waveform sample currently playing on a voice on the fly////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			volume = the volume to play the sample at, from 0 (off) to 255 (max).////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================int AsgardESS_SetWaveformVolume (int voice, int volume){	return AsgardESS_SetSampleVolume (voice, volume);}//=================================================================================================////		AsgardESS_StopWaveform////		Halts playback of the current waveform sample////=================================================================================================////		Inputs://			voice = the voice to stop playing on.////=================================================================================================void AsgardESS_StopWaveform (int voice){	AsgardESS_StopSample (voice);}//=================================================================================================////		AsgardESS_WaveformPlaying////		Returns true if a waveform sample is still playing on the given voice////=================================================================================================////		Inputs://			voice = the voice to check.////=================================================================================================int AsgardESS_WaveformPlaying (int voice){	return AsgardESS_SamplePlaying (voice);}#pragma mark ==================== Streamed Sample Playing//=================================================================================================////		AsgardESS_PlayStreamedSample////		Begins or continues playing a streamed sample on the given voice////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			pData = a pointer to the sampled 8-bit sound data////			length = the length of the sampled sound data, in bytes.////			frequency = the frequency to play the sample at, in Hz. Note that this is completely//						independent of the frequency specified to AsgardESS_Init. The sound sample//						will be converted on the fly to the output frequency.////			volume = the volume to play the sample at, from 0 (off) to 255 (max).////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================////		Notes://			Samples played via this function are immediately converted into mixable values and//			stashed off in a circular buffer waiting for the interrupt-level code to read them//			and add them directly into the mixing buffer.  This means that most of the sound//			processing will happen in mainline code, and not at interrupt time.  It also means,//			however, that if you are not emulating sound as quickly as the original machine, //			you will hear gaps of silence while the interrupt code waits for you to fill in more//			sound data.////=================================================================================================int AsgardESS_PlayStreamedSample (int voice, unsigned char *pData, long length, long frequency, int volume){	unsigned long in, out, space, pos, frac, step, streamBufferSize;	unsigned char normalize;	VoiceInfo *pVoice;	long *pDst, *pEnd;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice; 	streamBufferSize = pVoice->data.stream.size; 	// if we have no double-buffering for this voice yet, crank it up	if (pVoice->kind == kVoiceKindInactive)	{		// allocate space for the incoming buffer		streamBufferSize = gSound.doubleBufferFrames * STREAM_MULT;		pVoice->data.stream.pBuffer = AsgardESS_Malloc (SAMPLE_FRAMES_44kHz * STREAM_MULT * sizeof (long));		pVoice->data.stream.size = streamBufferSize;		if (!pVoice->data.stream.pBuffer)			return false;		aess_SetLongs (pVoice->data.stream.pBuffer, 0, streamBufferSize);				// set the kind to activate it		pVoice->kind = kVoiceKindStreamed;		pVoice->mixer = AsgardESS_MixStreamedSound;	}	// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindStreamed)		return false;		// get the current positions	in = pVoice->data.stream.in;	out = pVoice->data.stream.out;		// determine how much space is available	if (in >= out)		space = streamBufferSize - (in - out) - 1;	else		space = streamBufferSize - (in + streamBufferSize - out) - 1;		// compute the starting variables	pDst = pVoice->data.stream.pBuffer + in;	pEnd = pVoice->data.stream.pBuffer + streamBufferSize;	pos = pVoice->data.stream.pos;	frac = pVoice->data.stream.frac;	step = aess_ShiftAndDivide (frequency, gSound.frequency, FRAC_BITS);		// fold in the gain and get the normalization factor	volume = (volume * gSound.gain) >> 8;	normalize = gSound.normalizedXor;	// ================ Zero-volume case ================	if (volume < 1)	{		// loop while we have space and are not finished		while (pos < length && space > 0)		{			// zero the current sample			*pDst++ = 0;			if (pDst >= pEnd)				pDst = pVoice->data.stream.pBuffer;						// step forward and update the space left			frac += step;			pos += frac >> FRAC_BITS;			frac &= FRAC_MASK;			space -= 1;		}	}	// ================ Full-volume case ================	else if (volume > 254 && volume < 258)	{		// interpolated case		if (gSound.interpolated)		{			unsigned long temp;						// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				temp = pos + 1;				if (temp >= length)					temp = length - 1;				*pDst++ = aess_Interpolate ((signed char)(pData[pos] ^ normalize) << 8, (signed char)(pData[temp] ^ normalize) << 8, frac);				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}		else		{			// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				*pDst++ = (signed char)(pData[pos] ^ normalize) << 8;				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}	}	// ================== General case ==================	else	{		// interpolated case		if (gSound.interpolated)		{			unsigned long temp;						// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				temp = pos + 1;				if (temp >= length)					temp = length - 1;				*pDst++ = aess_Interpolate ((signed char)(pData[pos] ^ normalize) * volume, (signed char)(pData[temp] ^ normalize) * volume, frac);				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}		else		{			// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				*pDst++ = (signed char)(pData[pos] ^ normalize) * volume;				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}	}		// update the positions and announce we're ready	pVoice->data.stream.in = pDst - pVoice->data.stream.pBuffer;	if (pos >= length)		pVoice->data.stream.pos = pos - length, pVoice->data.stream.frac = frac;	else		pVoice->data.stream.pos = pVoice->data.stream.frac = 0;	pVoice->ready = true;	return true;}//=================================================================================================////		AsgardESS_PlayStreamedSample16////		Begins or continues playing a 16-bit streamed sample on the given voice////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			pData = a pointer to the sampled 16-bit (signed!) sound data////			length = the length of the sampled sound data, in samples.////			frequency = the frequency to play the sample at, in Hz. Note that this is completely//						independent of the frequency specified to AsgardESS_Init. The sound sample//						will be converted on the fly to the output frequency.////			volume = the volume to play the sample at, from 0 (off) to 255 (max).////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================int AsgardESS_PlayStreamedSample16 (int voice, short *pData, long length, long frequency, int volume){	unsigned long in, out, space, pos, frac, step, streamBufferSize;	VoiceInfo *pVoice;	long *pDst, *pEnd;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice; 	streamBufferSize = pVoice->data.stream.size; 	// if we have no double-buffering for this voice yet, crank it up	if (pVoice->kind == kVoiceKindInactive)	{		// allocate space for the incoming buffer		streamBufferSize = gSound.doubleBufferFrames * STREAM_MULT;		pVoice->data.stream.pBuffer = AsgardESS_Malloc (SAMPLE_FRAMES_44kHz * STREAM_MULT * sizeof (long));		pVoice->data.stream.size = streamBufferSize;		if (!pVoice->data.stream.pBuffer)			return false;		aess_SetLongs (pVoice->data.stream.pBuffer, 0, streamBufferSize);				// set the kind to activate it		pVoice->kind = kVoiceKindStreamed;		pVoice->mixer = AsgardESS_MixStreamedSound;	}	// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindStreamed)		return false;		// get the current positions	in = pVoice->data.stream.in;	out = pVoice->data.stream.out;		// determine how much space is available	if (in >= out)		space = streamBufferSize - (in - out) - 1;	else		space = streamBufferSize - (in + streamBufferSize - out) - 1;		// compute the starting variables	pDst = pVoice->data.stream.pBuffer + in;	pEnd = pVoice->data.stream.pBuffer + streamBufferSize;	pos = pVoice->data.stream.pos;	frac = pVoice->data.stream.frac;	step = aess_ShiftAndDivide (frequency, gSound.frequency, FRAC_BITS);	// fold in the gain	volume = (volume * gSound.gain) >> 8;	// ================ Zero-volume case ================	if (volume < 1)	{		// loop while we have space and are not finished		while (pos < length && space > 0)		{			// zero the current sample			*pDst++ = 0;			if (pDst >= pEnd)				pDst = pVoice->data.stream.pBuffer;						// step forward and update the space left			frac += step;			pos += frac >> FRAC_BITS;			frac &= FRAC_MASK;			space -= 1;		}	}	// ================ Full-volume case ================	else if (volume > 254 && volume < 258)	{		// interpolated case		if (gSound.interpolated)		{			unsigned long temp;						// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				temp = pos + 1;				if (temp >= length)					temp = length - 1;				*pDst++ = aess_Interpolate (pData[pos], pData[temp], frac);				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}		else		{			// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				*pDst++ = pData[pos];				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}	}	// ================== General case ==================	else	{		// interpolated case		if (gSound.interpolated)		{			unsigned long temp;						// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				temp = pos + 1;				if (temp >= length)					temp = length - 1;				*pDst++ = aess_Interpolate ((pData[pos] * volume) >> 8, (pData[temp] * volume) >> 8, frac);				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}		else		{			// loop while we have space and are not finished			while (pos < length && space > 0)			{				// grab the current sample and wrap it				*pDst++ = (pData[pos] * volume) >> 8;				if (pDst >= pEnd)					pDst = pVoice->data.stream.pBuffer;								// step forward and update the space left				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				space -= 1;			}		}	}		// update the positions and announce we're ready	pVoice->data.stream.in = pDst - pVoice->data.stream.pBuffer;	if (pos >= length)		pVoice->data.stream.pos = pos - length, pVoice->data.stream.frac = frac;	else		pVoice->data.stream.pos = pVoice->data.stream.frac = 0;	pVoice->ready = true;	return true;}#pragma mark ==================== Manual Sample Playing//=================================================================================================////		AsgardESS_PlayManual////		Begins playing a manually-generated sample on the given voice////=================================================================================================////		Inputs://			voice = the voice to play the sample on.////			pCallback = a pointer to a function which will get called back at interrupt time to//						generate sampled sound data.////			pUserData = a pointer which is passed through to the callback function above.////			dataSize = the size of the application-specific data that will be queued, in bytes.////			frequency = the frequency to play the sample at, in Hz. Note that this is completely//						independent of the frequency specified to AsgardESS_Init. The sound sample//						will be converted on the fly to the output frequency.////			volume = the volume to play the sample at, from 0 (off) to 255 (max).////		Returns://			true if the sample was successfully played; false otherwise////=================================================================================================////		Notes://			This function basically allows you to manually control a buffered sample-style voice.//			To use it, you simply start it going with this function, and then queue up commands//			with the AsgardESS_QueueManualData function.  Each queued command is timestamped,//			and then converted into a sample count at interrupt time.  The callback is then//			called, requesting you to generate the appropriate number of samples using the given//			queued data.  Like the buffered sample playing, above, most of the sound generation//			happens at interrupt time, and you will be able to avoid the gaps in playback you//			would get with streamed data.  At the same time, you get the ability to generate the//			samples yourself, just like with the streamed sample playback.////=================================================================================================int AsgardESS_PlayManual (int voice, AsgardESS_Fill pCallback, void *pUserData, long dataSize, long frequency, int volume){	VoiceInfo *pVoice;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;		// if we have no double-buffering for this channel yet, crank it up	if (pVoice->kind == kVoiceKindInactive)	{		// adjust the data size		pVoice->data.manual.dataSize = dataSize + sizeof (ManualSample);				// allocate space for the sample list		pVoice->data.manual.pList = AsgardESS_Malloc (BUFFER_LIST_ENTRIES * pVoice->data.manual.dataSize);		if (!pVoice->data.manual.pList)			return false;				// allocate space for the generation buffer		pVoice->data.manual.size = gSound.doubleBufferFrames * 44100 / gSound.frequency + 256;		pVoice->data.manual.pBuffer = AsgardESS_Malloc (SAMPLE_FRAMES_44kHz + 256);		if (!pVoice->data.manual.pBuffer)		{			AsgardESS_Free (pVoice->data.manual.pList);			return false;		}				// set the kind to activate it		pVoice->kind = kVoiceKindManual;		pVoice->mixer = AsgardESS_MixManualSound;	}	// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindManual)		return false;	// fill in the rest of the data	pVoice->data.manual.frequency = frequency;	pVoice->data.manual.volume		= volume;	pVoice->data.manual.pCallback	= pCallback;	pVoice->data.manual.pUserData	= pUserData;		return true;}//=================================================================================================////		AsgardESS_PlayManual16////		Begins playing a manually-generated 16-bit sample on the given voice////=================================================================================================////		Same as above, but sets things up for 16-bit playback////=================================================================================================int AsgardESS_PlayManual16 (int voice, AsgardESS_Fill16 pCallback, void *pUserData, long dataSize, long frequency, int volume){	VoiceInfo *pVoice;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;		// if we have no double-buffering for this channel yet, crank it up	if (pVoice->kind == kVoiceKindInactive)	{		// adjust the data size		pVoice->data.manual.dataSize = dataSize + sizeof (ManualSample);				// allocate space for the sample list		pVoice->data.manual.pList = AsgardESS_Malloc (BUFFER_LIST_ENTRIES * pVoice->data.manual.dataSize);		if (!pVoice->data.manual.pList)			return false;				// allocate space for the generation buffer		pVoice->data.manual.size = gSound.doubleBufferFrames * 44100 / gSound.frequency + 256;		pVoice->data.manual.pBuffer = AsgardESS_Malloc (sizeof (short) * (SAMPLE_FRAMES_44kHz + 256));		if (!pVoice->data.manual.pBuffer)		{			AsgardESS_Free (pVoice->data.manual.pList);			return false;		}				// set the kind to activate it		pVoice->kind = kVoiceKindManual16;		pVoice->mixer = AsgardESS_MixManualSound16;	}	// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindManual16)		return false;	// fill in the rest of the data	pVoice->data.manual.frequency = frequency;	pVoice->data.manual.volume		= volume;	pVoice->data.manual.pCallback	= pCallback;	pVoice->data.manual.pUserData	= pUserData;		return true;}//=================================================================================================////		AsgardESS_QueueManualData////		Queues a command for processing in a manual data voice////=================================================================================================////		Inputs://			voice = the voice to queue the command for.////			pData = a pointer to the application-specific data.////		Returns://			true if the command was successfully queued; false otherwise////=================================================================================================int AsgardESS_QueueManualData (int voice, void *pData){	ManualSample *pSample;	UnsignedWide time;	VoiceInfo *pVoice;	int next;		// bail if we're not ready or if there's an invalid voice	if (!gSound.soundActive || voice >= gSound.voices)		return false;	pVoice = gSound.pVoice + voice;	// bail if this is the wrong kind of voice	if (pVoice->kind != kVoiceKindManual && pVoice->kind != kVoiceKindManual16)		return false;	// determine where to add the sample	pSample = (ManualSample *)((char *)pVoice->data.manual.pList + pVoice->data.manual.in * pVoice->data.manual.dataSize);	next = (pVoice->data.manual.in + 1) & BUFFER_LIST_MASK;		// if we've wrapped around, bail	if (next == pVoice->data.manual.out)		return false;		// fill in the data for this sample	Microseconds (&time);	pSample->time = time.lo;	BlockMoveData (pData, pSample->userData, pVoice->data.manual.dataSize - sizeof (ManualSample));		// advance the incoming pointer and announce we're ready	pVoice->data.manual.in = next;	pVoice->ready = true;		return true;}#pragma mark ==================== Memory Utilities//=================================================================================================////		AsgardESS_Malloc////		Allocate a block of memory and force it to remain resident, protected from VM paging////=================================================================================================////		Inputs://			size = amount of memory to allocate.////		Returns://			a pointer to the newly-allocated memory, or NULL if there was an error.////=================================================================================================static void *AsgardESS_Malloc (long size){	void *p;		// allocate the memory	p = malloc (size + 4);	if (!p)		return NULL;	// clear the memory	memset (p, 0, size + 4);		// store a long at the beginning to remember the size	*(long *)p = size;			// hold the result	HoldMemory (p, size + 4);	return (long *)p + 1;}//=================================================================================================////		AsgardESS_Free////		Free a block of memory allocated above////=================================================================================================////		Inputs://			pMemory = pointer to the previously-allocated memory block.////=================================================================================================static void AsgardESS_Free (void *pMemory){	void *p = (long *)pMemory - 1;	long size;		// allow NULL pointers here	if (!pMemory)		return;	// retrieve the size	size = *(long *)p;		// unhold the memory	UnholdMemory (p, size + 4);		// free it	free (p);}//=================================================================================================////		AsgardESS_Set////		Clears an arbitrary block of memory to a specified 8-bit value////=================================================================================================////		Inputs://			pData = pointer to the memory to clear.////			val = the 8-bit value to fill the memory with.////			count = the number of 8-bit values to store.////=================================================================================================static void AsgardESS_Set (void *pData, unsigned char val, long count){	unsigned long *pDest = pData, lval;	int lcount = count >> 2;		// make copies in all four bytes	lval = (val << 8) + val;	lval = (lval << 16) + lval;	// fill longs	while (lcount--)		*pDest++ = lval;	// fill in an extra short if needed	if (count & 2)	{		*(unsigned short *)pDest = lval;		pDest = (unsigned long *)((unsigned short *)pDest + 1);	}	// fill in an extra char if needed	if (count & 1)		*(unsigned char *)pDest = lval;}#pragma mark ==================== OS Utilities//=================================================================================================////		AsgardESS_PatchExitToShell////		Installs an ExitToShell patch which terminates the Asgard ESS if it was active.////=================================================================================================#if !GENERATINGCFMstatic void AsgardESS_PatchExitToShell (void){	static int alreadyPatched = false;		// don't bother if we've already done it	if (alreadyPatched)		return;		// remember the A5 statically	AsgardESS_RememberA5 ();		// remember the old address	pOldExitToShell = NGetTrapAddress (0xA9F4, ToolTrap);		// patch in the new address	NSetTrapAddress ((ProcPtr)AsgardESS_ExitToShell, 0xA9F4, ToolTrap);		// remember that we succeeded	alreadyPatched = true;}#endif//=================================================================================================////		AsgardESS_ExitToShell////		The ExitToShell patch for non-CFM 68k machines.////=================================================================================================#if !GENERATINGCFMstatic asm void AsgardESS_ExitToShell (void){	move.l		tempA5,a5						// restore A5	jsr			AsgardESS_Term					// kill the system	move.l		pOldExitToShell,a0			// get the old trap address	jmp			(a0)								// go theretempA5:	dc.l			0									// static storage for A5entry static 	AsgardESS_RememberA5	lea			tempA5,a0						// get a pointer to our static A5	move.l		a5,(a0)							// store the current A5 there	rts												// return home}#endif#pragma mark ==================== Table Generation//=================================================================================================////		AsgardESS_MakeMixerTable////		Creates the n-voice mixdown table////=================================================================================================////		Inputs://			sixteenBit = true if the we will be outputting 16-bit data.  By creating this table//						appropriately, we can fold in all the vagaries of producing normalized//						8-bit or 16-bit samples without needing to complicate code.////=================================================================================================////		Notes://			Essentially, all the mixers produce a value that is the sum of n voices of data,//			with each voice scaled to -4096..4095 to maintain extra resolution during mixing.//			The final mixing step is to take each of these, shift off the extra 4 bits, and then//			look up the resulting value in this table.  Thus, this table needs to have 256 * n//			entries.////			In addition to avoiding the divide that would be necessary, we also produce a more//			complex mixing table that doesn't penalize you as harshly for being able to handle,//			say, 8 voices maximum even when you're normally only playing 2 or 3.  Essentially,//			the table is linear at small values, so that single voices are bright and loud, and//			then curves at larger values to prevent clipping.////=================================================================================================static void AsgardESS_MakeMixerTable (int sixteenBit){	int count = gSound.voices * 128;	double di, mult, inc;	int i;	// compute the multiplier	mult = ((double)gSound.voices - 1.0) / (double)gSound.voices;	inc = (double)gSound.voices / (double)(count * 16);		// sixteen-bit case	if (sixteenBit)	{		short *pMiddle;				// find the middle of the table		gSound.pMixerMiddle = pMiddle = (short *)gSound.pMixerTable + (gSound.voices * 128 * 16);		// fill in the table		for (i = 0, di = 0.0; i < count * 16; i++, di += inc)		{			signed short val = (signed short)(di * 32767.0 / (mult * di + 1));			pMiddle[ i] = val;			pMiddle[-i] = -val;		}	}	// eight-bit case	else	{		unsigned char *pMiddle;				// find the middle of the table		gSound.pMixerMiddle = pMiddle = (unsigned char *)gSound.pMixerTable + (gSound.voices * 128 * 16);		// fill in the table		for (i = 0, di = 0.0; i < count * 16; i++, di += inc)		{			signed char val = (signed char)(di * 127.0 / (mult * di + 1));			pMiddle[ i] = val ^ 0x80;			pMiddle[-i] = -val ^ 0x80;		}	}}//=================================================================================================////		AsgardESS_GenerateTables////		Generates the lookup tables and built-in sound samples, using the current parameters//		in the global sound structure////=================================================================================================static void AsgardESS_GenerateTables (void){	unsigned char *pNoise;	short *pNoise16;	int i;		// fill the mixer table	AsgardESS_MakeMixerTable (gSound.sixteenBit);		// create the silent samples	gSound.silentSample[0] = 0x00 ^ gSound.normalizedXor;	gSound.silentSample16[0] = 0x0000;		// create the square wave samples	gSound.squareSample[0] = 0x7f ^ gSound.normalizedXor;	gSound.squareSample[1] = gSound.silentSample[0];	gSound.squareSample16[0] = 0x7fff;	gSound.squareSample16[1] = gSound.silentSample16[0];		// create the noise samples	pNoise = gSound.noiseSample;	pNoise16 = gSound.noiseSample16;	for (i = 0; i < sizeof (gSound.noiseSample); i++)	{		*pNoise++ = (Random () & 0x4000) ? gSound.squareSample[0] : gSound.squareSample[1];		*pNoise16++ = (Random () & 0x4000) ? gSound.squareSample16[0] : gSound.squareSample16[1];	}}#pragma mark ==================== Sound Mixing//=================================================================================================////		AsgardESS_ComputeSoundInterval////		Computes the absolute microsecond interval that the current chunk of sound should represent.//		This is necessary because the Sound Manager does not always generate perfectly regular//		sound intervals, and so some tweaking must be done to keep up with it.  This algorithm//		learns the appropriate timing over a short period of time and self-adjusts to keep regular.////=================================================================================================////		Inputs://			pSound = pointer to the sound globals.////		Returns://			The absolute microsecond tick this sound interval begins at; the length of the interval//			can be found in pSound->usecsPerCallback.////=================================================================================================static unsigned long AsgardESS_ComputeSoundInterval (SoundGlobals *pSound){	unsigned long intervalStart;	signed long latency;	UnsignedWide time;	// get the current time	Microseconds (&time);	// if this is one of the first 4 callbacks, just slam the time until the system settles down	if (pSound->callbackCount++ < 4)		intervalStart = time.lo - BASE_LATENCY - pSound->usecsPerCallback;		// otherwise, we get to have fun	else	{		// this interval of sound starts at the previously computed time		intervalStart = pSound->computedTime;			// if this is our first time, compute an interval start with the necessary latency		if (!intervalStart)			intervalStart = time.lo - BASE_LATENCY - pSound->usecsPerCallback;			// compute the start of the next interval		pSound->computedTime = intervalStart + pSound->usecsPerCallback;		// compute the current latency		latency = time.lo - pSound->computedTime;				// if this latency is the smallest we've seen, remember it		if (latency < pSound->minLatency)			pSound->minLatency = latency;		// once every 32 callbacks (about once every 1.5 seconds), check our latency		if (!(pSound->callbackCount & 31))		{			// if the minimum latency we saw is too high, bump ourselves forward			if (pSound->minLatency > MAX_LATENCY)			{				pSound->computedTime += (MAX_LATENCY - BASE_LATENCY);				pSound->usecsPerCallback += ((MAX_LATENCY - BASE_LATENCY) / 10) / (pSound->callbackCount - pSound->resetCount);				pSound->resetCount = pSound->callbackCount;			}							// if the minimum latency we saw is too low, push ourselves backward			else if (pSound->minLatency < MIN_LATENCY)			{				pSound->computedTime -= (BASE_LATENCY - MIN_LATENCY);				pSound->usecsPerCallback -= ((BASE_LATENCY - MIN_LATENCY) / 10) / (pSound->callbackCount - pSound->resetCount);				pSound->resetCount = pSound->callbackCount;			}						// reset the minimum latency			pSound->minLatency = 0x7fffffff;		}	}		// return the result	return intervalStart;}//=================================================================================================////		AsgardESS_MixStreamedSound////		Mixes streamed (pre-processed) sound samples into a mix buffer////=================================================================================================////		Inputs://			pSound = pointer to the sound globals structure.////			pVoice = pointer to the data for the current voice.////			time = the low word of the current microseconds time value.////=================================================================================================static void AsgardESS_MixStreamedSound (SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long base){#pragma unused(base)	unsigned long in, out, samples, streamBufferSize = pVoice->data.stream.size;	long count = pSound->doubleBufferFrames;	long *pMix = pSound->pMixBuffer, last;	long *pSrc, *pEnd;	// see how many samples we currently have	in = pVoice->data.stream.in;	out = pVoice->data.stream.out;	if (in >= out)		samples = in - out;	else		samples = in + streamBufferSize - out;		// determine how many to copy	samples = (samples >= count) ? count : samples;	count -= samples;		// get the data pointers	pSrc = pVoice->data.stream.pBuffer + out;	pEnd = pVoice->data.stream.pBuffer + streamBufferSize;		// now mix in the data	while (samples--)	{		*pMix++ += *pSrc++;		if (pSrc >= pEnd)			pSrc = pVoice->data.stream.pBuffer;	}		// pad with the final sample	if (count)	{		last = (pSrc == pVoice->data.stream.pBuffer) ? pEnd[-1] : pSrc[-1];		while (count--)			*pMix++ = last;	}		// update the output position	pVoice->data.stream.out = pSrc - pVoice->data.stream.pBuffer;}//=================================================================================================////		AsgardESS_MixBufferedSound////		Mixes buffered sound samples into a mix buffer with no interpolation////=================================================================================================////		Inputs://			pSound = pointer to the sound globals structure.////			pVoice = pointer to the data for the current voice.////			time = the low word of the current microseconds time value.////=================================================================================================static void AsgardESS_MixBufferedSound (SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long base){	unsigned long end, step, frac, pos, usec, length, inc;	long *pMix = pSound->pMixBuffer, lastSample;	int out, next, last, loop, samples, volume;	long count = pSound->doubleBufferFrames;	BufferedSample *pList, *pCurr, *pNext;	unsigned char *pSrc, normalize;		// restore our location in the sample list	last = (pVoice->data.buffer.in - 1) & BUFFER_LIST_MASK;	out = pVoice->data.buffer.out;	next = (out + 1) & BUFFER_LIST_MASK;	// compute the number of microseconds per sample	inc = (1000000 << 8) / pSound->frequency;	usec = 0;		// restore the previous sample position	pos = pVoice->data.buffer.pos;	frac = pVoice->data.buffer.frac;	lastSample = pVoice->data.buffer.lastSample;	// restore the list pointers	pList = pVoice->data.buffer.pList;	pCurr = pList + out;	pNext = pList + next;	// restore the current output sample data	pSrc = pCurr->pSample;	length = pCurr->length;	step = aess_ShiftAndDivide (pCurr->frequency, gSound.frequency, FRAC_BITS);	loop = pCurr->loop;	// set up the volume	volume = (pCurr->volume * pSound->gain) >> 8;	normalize = pSound->normalizedXor;		// determine the microsecond tick when this entry ends, correcting for negative time	end = (out != last) ? (pNext->time - base) : 0xffffffff;	if ((end + 1) > 1000000)		end = usec;	else		end <<= 8;	// loop over the destination size			while (count)	{		// determine how many samples to generate		if (end > usec)		{			samples = (end - usec) / inc;			if (samples > count)				samples = count;		}		else			samples = 0;				// zero-volume case		if (volume < 1)		{			lastSample = 0;			while (samples--)			{				// update the sample position				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				count -= 1;				usec += inc;				// handle overflow				if (pos >= length)				{					// if we're looping, just wrap					if (loop)					{						while (pos >= length)							pos -= length;					}										// otherwise, convert to silence until we hear otherwise					else					{						pCurr->pSample = pSrc = pSound->silentSample;						pCurr->frequency = step = 0;						pos = frac = 0;						pVoice->data.buffer.playing = false;					}				}			}		}		// mix it interpolated		else if (pSound->interpolated)		{			// loop over samples			while (samples--)			{				// copy in the current sample				long sample = (signed char)(pSrc[pos] ^ normalize) * volume;				*pMix++ += aess_Interpolate (lastSample, sample, frac);				lastSample = sample;				// update the sample position				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				count -= 1;				usec += inc;				// handle overflow				if (pos >= length)				{					// if we're looping, just wrap					if (loop)					{						while (pos >= length)							pos -= length;					}										// otherwise, convert to silence until we hear otherwise					else					{						pCurr->pSample = pSrc = pSound->silentSample;						pCurr->frequency = step = 0;						pos = frac = 0;						pVoice->data.buffer.playing = false;					}				}			}		}				// mix it non-interpolated		else		{			// loop over samples			while (samples--)			{				// copy in the current sample				*pMix++ += (signed char)(pSrc[pos] ^ normalize) * volume;								// update the sample position				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				count -= 1;				usec += inc;				// handle overflow				if (pos >= length)				{					// if we're looping, just wrap					if (loop)					{						while (pos >= length)							pos -= length;					}										// otherwise, convert to silence until we hear otherwise					else					{						pCurr->pSample = pSrc = pSound->silentSample;						pCurr->frequency = step = 0;						pos = frac = 0;						pVoice->data.buffer.playing = false;					}				}			}		}		// if we've got more to do, advance		if (count)		{			// determine the next pointer			out = next;			next = (next + 1) & BUFFER_LIST_MASK;						// if this is a new sample, reset the position			pCurr = pNext;			pNext = pList + next;			if (pSrc != pCurr->pSample)			{				pSrc = pCurr->pSample;				length = pCurr->length;				pos = frac = 0;			}						// update the frequency/volume/loop			step = aess_ShiftAndDivide (pCurr->frequency, gSound.frequency, FRAC_BITS);			loop = pCurr->loop;			// set up the volume			volume = (pCurr->volume * pSound->gain) >> 8;				// determine the microsecond tick when this entry ends, correcting for negative time			end = (out != last) ? (pNext->time - base) : 0xffffffff;			if ((end + 1) > 1000000)				end = usec;			else				end <<= 8;		}	}	// remember where we were	pVoice->data.buffer.pos = pos;	pVoice->data.buffer.frac = frac;	pVoice->data.buffer.out = out;	pVoice->data.buffer.lastSample = lastSample;}//=================================================================================================////		AsgardESS_MixBufferedSound16////		Mixes buffered 16-bit sound samples into a mix buffer with no interpolation////=================================================================================================////		Inputs://			pSound = pointer to the sound globals structure.////			pVoice = pointer to the data for the current voice.////			time = the low word of the current microseconds time value.////=================================================================================================static void AsgardESS_MixBufferedSound16 (SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long base){	unsigned long end, step, frac, pos, usec, length, inc;	long *pMix = pSound->pMixBuffer, lastSample;	int out, next, last, loop, samples, volume;	long count = pSound->doubleBufferFrames;	BufferedSample *pList, *pCurr, *pNext;	short *pSrc, normalize;		// restore our location in the sample list	last = (pVoice->data.buffer.in - 1) & BUFFER_LIST_MASK;	out = pVoice->data.buffer.out;	next = (out + 1) & BUFFER_LIST_MASK;	// compute the number of microseconds per sample	inc = (1000000 << 8) / pSound->frequency;	usec = 0;		// restore the previous sample position	pos = pVoice->data.buffer.pos;	frac = pVoice->data.buffer.frac;	lastSample = pVoice->data.buffer.lastSample;	// restore the list pointers	pList = pVoice->data.buffer.pList;	pCurr = pList + out;	pNext = pList + next;	// restore the current output sample data	pSrc = (short *)pCurr->pSample;	length = pCurr->length;	step = aess_ShiftAndDivide (pCurr->frequency, gSound.frequency, FRAC_BITS);	loop = pCurr->loop;	// set up the volume	volume = (pCurr->volume * pSound->gain) >> 8;	normalize = pSound->normalizedXor;		// determine the microsecond tick when this entry ends, correcting for negative time	end = (out != last) ? (pNext->time - base) : 0xffffffff;	if ((end + 1) > 1000000)		end = usec;	else		end <<= 8;	// loop over the destination size			while (count)	{		// determine how many samples to generate		if (end > usec)		{			samples = (end - usec) / inc;			if (samples > count)				samples = count;		}		else			samples = 0;				// zero-volume case		if (volume < 1)		{			lastSample = 0;			while (samples--)			{				// update the sample position				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				count -= 1;				usec += inc;				// handle overflow				if (pos >= length)				{					// if we're looping, just wrap					if (loop)					{						while (pos >= length)							pos -= length;					}										// otherwise, convert to silence until we hear otherwise					else					{						pCurr->pSample = pSrc = 0;						pCurr->frequency = step = 0;						pos = frac = 0;						pVoice->data.buffer.playing = false;					}				}			}		}		// mix it interpolated		else if (pSound->interpolated)		{			// loop over samples			while (samples--)			{				// copy in the current sample				long sample = (pSrc[pos] * volume) >> 8;				*pMix++ += aess_Interpolate (lastSample, sample, frac);				lastSample = sample;				// update the sample position				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				count -= 1;				usec += inc;				// handle overflow				if (pos >= length)				{					// if we're looping, just wrap					if (loop)					{						while (pos >= length)							pos -= length;					}										// otherwise, convert to silence until we hear otherwise					else					{						pCurr->pSample = pSrc = 0;						pCurr->frequency = step = 0;						pos = frac = 0;						pVoice->data.buffer.playing = false;					}				}			}		}				// mix it non-interpolated		else		{			// loop over samples			while (samples--)			{				// copy in the current sample				*pMix++ += (pSrc[pos] * volume) >> 8;								// update the sample position				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;				count -= 1;				usec += inc;				// handle overflow				if (pos >= length)				{					// if we're looping, just wrap					if (loop)					{						while (pos >= length)							pos -= length;					}										// otherwise, convert to silence until we hear otherwise					else					{						pCurr->pSample = pSrc = 0;						pCurr->frequency = step = 0;						pos = frac = 0;						pVoice->data.buffer.playing = false;					}				}			}		}		// if we've got more to do, advance		if (count)		{			// determine the next pointer			out = next;			next = (next + 1) & BUFFER_LIST_MASK;						// if this is a new sample, reset the position			pCurr = pNext;			pNext = pList + next;			if (pSrc != (short *)pCurr->pSample)			{				pSrc = (short *)pCurr->pSample;				length = pCurr->length;				pos = frac = 0;			}						// update the frequency/volume/loop			step = aess_ShiftAndDivide (pCurr->frequency, gSound.frequency, FRAC_BITS);			loop = pCurr->loop;			// set up the volume			volume = (pCurr->volume * pSound->gain) >> 8;				// determine the microsecond tick when this entry ends, correcting for negative time			end = (out != last) ? (pNext->time - base) : 0xffffffff;			if ((end + 1) > 1000000)				end = usec;			else				end <<= 8;		}	}	// remember where we were	pVoice->data.buffer.pos = pos;	pVoice->data.buffer.frac = frac;	pVoice->data.buffer.out = out;	pVoice->data.buffer.lastSample = lastSample;}//=================================================================================================////		AsgardESS_MixManualSound////		Mixes manually-generated sound samples into a mix buffer with no interpolation////=================================================================================================////		Inputs://			pSound = pointer to the sound globals structure.////			pVoice = pointer to the data for the current voice.////			time = the low word of the current microseconds time value.////=================================================================================================static void AsgardESS_MixManualSound (SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long base){	AsgardESS_Fill pCallback = pVoice->data.manual.pCallback;	unsigned long end, step, pos, frac, usec, inc, needed, samples;	ManualSample *pList, *pCurr, *pNext, *pLast;	long count = pSound->doubleBufferFrames;	int out, next, last, voice, volume;	long *pMix = pSound->pMixBuffer;	unsigned char *pDst, normalize;		// determine voice index	voice = pVoice - pSound->pVoice;		// restore our location in the sample list	last = (pVoice->data.manual.in - 1) & BUFFER_LIST_MASK;	out = pVoice->data.manual.out;	next = (out + 1) & BUFFER_LIST_MASK;	// compute the number of microseconds per sample	inc = (1000000 << 8) / pVoice->data.manual.frequency;	usec = 0;	// restore the previous sample position and frequency step	pos = 0;	frac = pVoice->data.manual.frac;	step = aess_ShiftAndDivide (pVoice->data.manual.frequency, gSound.frequency, FRAC_BITS);	// restore the list pointers	pList = pVoice->data.manual.pList;	pCurr = (ManualSample *)((char *)pList + out * pVoice->data.manual.dataSize);	pNext = (ManualSample *)((char *)pList + next * pVoice->data.manual.dataSize);	pLast = pVoice->data.manual.pLast;	// compute how many samples we need to generate, plus one for interpolation	needed = ((count * (step >> (FRAC_BITS - 16))) >> 16) - pVoice->data.manual.leftOvers + 1;	// determine the microsecond tick when this entry ends, correcting for negative time	end = (out != last) ? (pNext->time - base) : 0xffffffff;	if ((end + 1) > 1000000)		end = usec;	else		end <<= 8;		// get the pointer to the destination	pDst = pVoice->data.manual.pBuffer + pVoice->data.manual.leftOvers;	// loop over the destination size	while (needed)	{		// determine how many samples to generate		if (end > usec)		{			samples = (end - usec) / inc;			if (samples > needed)				samples = needed;		}		else			samples = 0;		// do it		(*pCallback)(voice, pDst, samples, (pCurr == pLast) ? NULL : pCurr->userData, pVoice->data.manual.pUserData);		pLast = pCurr;				// update the counts		pDst += samples;		needed -= samples;		usec += samples * inc;		// if we've got more to do, advance		if (needed)		{			// determine the next pointer			out = next;			next = (next + 1) & BUFFER_LIST_MASK;						// if this is a new sample, reset the position			pCurr = pNext;			pNext = (ManualSample *)((char *)pList + next * pVoice->data.manual.dataSize);				// determine the microsecond tick when this entry ends, correcting for negative time			end = (out != last) ? (pNext->time - base) : 0xffffffff;			if ((end + 1) > 1000000)				end = usec;			else				end <<= 8;		}	}		// determine the last sample generated	end = pDst - pVoice->data.manual.pBuffer;		// fold in the gain	volume = (pVoice->data.manual.volume * pSound->gain) >> 8;	normalize = pSound->normalizedXor;	pDst = pVoice->data.manual.pBuffer;	// zero-volume case	if (volume < 1)	{		// loop over the destination length		while (count--)		{			// grab the current sample and step forward			frac += step;			pos += frac >> FRAC_BITS;			frac &= FRAC_MASK;		}	}		// full-volume case	else if (volume > 254 && volume < 258)	{		// interpolated case		if (pSound->interpolated)		{			unsigned long temp;			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				temp = pos + 1;				*pMix++ = aess_Interpolate ((signed char)(pDst[pos] ^ normalize) << 8, (signed char)(pDst[temp] ^ normalize) << 8, frac);				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}		else		{			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				*pMix++ += (signed char)(pDst[pos] ^ normalize) << 8;				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}	}		else	{		// interpolated case		if (pSound->interpolated)		{			unsigned long temp;			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				temp = pos + 1;				*pMix++ = aess_Interpolate ((signed char)(pDst[pos] ^ normalize) * volume, (signed char)(pDst[temp] ^ normalize) * volume, frac);				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}		else		{			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				*pMix++ += (signed char)(pDst[pos] ^ normalize) * volume;				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}	}		// normalize the last few samples	pVoice->data.manual.leftOvers = end - pos;	BlockMoveData (pVoice->data.manual.pBuffer + pos, pVoice->data.manual.pBuffer, pVoice->data.manual.leftOvers);		// remember where we were	pVoice->data.manual.frac = frac;	pVoice->data.manual.out = out;	pVoice->data.manual.pLast = pLast;}//=================================================================================================////		AsgardESS_MixManual16Sound////		Mixes manually-generated 16-bit sound samples into a mix buffer with no interpolation////=================================================================================================////		Inputs://			pSound = pointer to the sound globals structure.////			pVoice = pointer to the data for the current voice.////			time = the low word of the current microseconds time value.////=================================================================================================static void AsgardESS_MixManualSound16 (SoundGlobals *pSound, VoiceInfo *pVoice, unsigned long base){	AsgardESS_Fill16 pCallback = pVoice->data.manual.pCallback;	unsigned long end, step, pos, frac, usec, inc, needed, samples;	ManualSample *pList, *pCurr, *pNext, *pLast;	long count = pSound->doubleBufferFrames;	int out, next, last, voice, volume;	long *pMix = pSound->pMixBuffer;	short *pDst;		// determine voice index	voice = pVoice - pSound->pVoice;		// restore our location in the sample list	last = (pVoice->data.manual.in - 1) & BUFFER_LIST_MASK;	out = pVoice->data.manual.out;	next = (out + 1) & BUFFER_LIST_MASK;	// compute the number of microseconds per sample	inc = (1000000 << 8) / pVoice->data.manual.frequency;	usec = 0;	// restore the previous sample position and frequency step	pos = 0;	frac = pVoice->data.manual.frac;	step = aess_ShiftAndDivide (pVoice->data.manual.frequency, gSound.frequency, FRAC_BITS);	// restore the list pointers	pList = pVoice->data.manual.pList;	pCurr = (ManualSample *)((char *)pList + out * pVoice->data.manual.dataSize);	pNext = (ManualSample *)((char *)pList + next * pVoice->data.manual.dataSize);	pLast = pVoice->data.manual.pLast;	// compute how many samples we need to generate, plus one for interpolation	needed = ((count * (step >> (FRAC_BITS - 16))) >> 16) - pVoice->data.manual.leftOvers + 1;	// determine the microsecond tick when this entry ends, correcting for negative time	end = (out != last) ? (pNext->time - base) : 0xffffffff;	if ((end + 1) > 1000000)		end = usec;	else		end <<= 8;		// get the pointer to the destination	pDst = (short *)pVoice->data.manual.pBuffer + pVoice->data.manual.leftOvers;	// loop over the destination size	while (needed)	{		// determine how many samples to generate		if (end > usec)		{			samples = (end - usec) / inc;			if (samples > needed)				samples = needed;		}		else			samples = 0;		// do it		(*pCallback)(voice, pDst, samples, (pCurr == pLast) ? NULL : pCurr->userData, pVoice->data.manual.pUserData);		pLast = pCurr;				// update the counts		pDst += samples;		needed -= samples;		usec += samples * inc;		// if we've got more to do, advance		if (needed)		{			// determine the next pointer			out = next;			next = (next + 1) & BUFFER_LIST_MASK;						// if this is a new sample, reset the position			pCurr = pNext;			pNext = (ManualSample *)((char *)pList + next * pVoice->data.manual.dataSize);				// determine the microsecond tick when this entry ends, correcting for negative time			end = (out != last) ? (pNext->time - base) : 0xffffffff;			if ((end + 1) > 1000000)				end = usec;			else				end <<= 8;		}	}		// determine the last sample generated	end = pDst - (short *)pVoice->data.manual.pBuffer;		// set up the volume and destination pointer	volume = (pVoice->data.manual.volume * pSound->gain) >> 8;	pDst = (short *)pVoice->data.manual.pBuffer;	// zero-volume case	if (volume < 1)	{		// loop over the destination length		while (count--)		{			// grab the current sample and step forward			frac += step;			pos += frac >> FRAC_BITS;			frac &= FRAC_MASK;		}	}		// full-volume case	else if (volume > 254 && volume < 258)	{		// interpolated case		if (pSound->interpolated)		{			unsigned long temp;			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				temp = pos + 1;				*pMix++ = aess_Interpolate (pDst[pos], pDst[temp], frac);				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}		else		{			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				*pMix++ += pDst[pos];				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}	}		else	{		// interpolated case		if (pSound->interpolated)		{			unsigned long temp;			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				temp = pos + 1;				*pMix++ = aess_Interpolate ((pDst[pos] * volume) >> 8, (pDst[temp] * volume) >> 8, frac);				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}		else		{			// loop over the destination length			while (count--)			{				// grab the current sample and step forward				*pMix++ += (pDst[pos] * volume) >> 8;				frac += step;				pos += frac >> FRAC_BITS;				frac &= FRAC_MASK;			}		}	}		// normalize the last few samples	pVoice->data.manual.leftOvers = end - pos;	BlockMoveData (pVoice->data.manual.pBuffer + pos, pVoice->data.manual.pBuffer, pVoice->data.manual.leftOvers);		// remember where we were	pVoice->data.manual.frac = frac;	pVoice->data.manual.out = out;	pVoice->data.manual.pLast = pLast;}#pragma mark ==================== Sound Manager Interface//=================================================================================================////		AsgardESS_DoubleBackStart////		Starts double-buffered sound playback via the Sound Manager, using the current parameters//		in the global sound structure////=================================================================================================static OSErr AsgardESS_DoubleBackStart (void){	int sixteenBit = gSound.sixteenBit;	OSErr err;	int i;		// make sure ExitToShell is patched before we go any farther	#if !GENERATINGCFM	AsgardESS_PatchExitToShell ();	#endif	// create a sound channel	err = SndNewChannel (&gSound.pChannel, sampledSynth, initMono + initNoInterp + initNoDrop, nil);	if (err != noErr)		return err;		// make sure we don't stop early	gSound.soundEnd = false;	// compute the number of frames to give us ~1/22 of a second latency	gSound.doubleBufferFrames = 2048 * gSound.frequency / 44100;	gSound.doubleBufferFrames = (gSound.doubleBufferFrames + 511) & ~511;	gSound.doubleBufferSize = sixteenBit ? 2 * gSound.doubleBufferFrames : gSound.doubleBufferFrames;		// precompute the number of usecs per callback and reset the latency calculation	gSound.usecsPerCallback = (unsigned long)(1000000.0 * (double)gSound.doubleBufferFrames / (double)gSound.frequency);	gSound.computedTime = 0;	gSound.minLatency = 0;	gSound.callbackCount = 0;	gSound.resetCount = 0;		// fill in the double-buffer header	gSound.dbHeader.dbhNumChannels     = 1;	gSound.dbHeader.dbhSampleSize      = sixteenBit ? 16 : 8;	gSound.dbHeader.dbhSampleRate      = (unsigned long)gSound.frequency << 16;	// set up the double back routine	gSound.dbHeader.dbhDoubleBack = pDoubleBack;		// fill in the two buffer headers	for (i = 0; i < 2; i++)	{		// initialize the data		gSound.dbHeader.dbhBufferPtr[i]->dbNumFrames   = gSound.doubleBufferSize;		gSound.dbHeader.dbhBufferPtr[i]->dbFlags       = dbBufferReady;		gSound.dbHeader.dbhBufferPtr[i]->dbUserInfo[0] = (unsigned long)&gSound;		gSound.dbHeader.dbhBufferPtr[i]->dbUserInfo[1] = SetCurrentA5 ();				// clear the buffer to silence		aess_SetLongs (gSound.dbHeader.dbhBufferPtr[i]->dbSoundData, (sixteenBit) ? 0x00000000 : 0x80808080, gSound.doubleBufferSize >> 2);	}	// start the buffering going	err = SndPlayDoubleBuffer (gSound.pChannel, &gSound.dbHeader);		// if all went well, mark the system active	if (err == noErr)		gSound.soundActive = true;	else	{		SndDisposeChannel (gSound.pChannel, true);		gSound.pChannel = nil;	}	return err;}//=================================================================================================////		AsgardESS_DoubleBackStop////		Stops double-buffered playback through the sound manager////=================================================================================================static void AsgardESS_DoubleBackStop (void){	// force the double buffering to end	while (gSound.soundActive)		gSound.soundEnd = true;	// kill the channel	if (gSound.pChannel)		SndDisposeChannel (gSound.pChannel, true);	gSound.pChannel = nil;}//=================================================================================================////		AsgardESS_DoubleBack////		The Sound Manager low-level double buffering routine////=================================================================================================////		Inputs://			pChannel = the sound manager channel we're playing from.////			pDoubleBuffer = pointer to the active double buffer structure.////=================================================================================================static pascal void AsgardESS_DoubleBack (SndChannelPtr pChannel, SndDoubleBufferPtr pDoubleBuffer){#pragma unused(pChannel)	SoundGlobals *pSound = (SoundGlobals *)pDoubleBuffer->dbUserInfo[0];	unsigned long count, intervalStart, dbSize = pSound->doubleBufferFrames;	VoiceInfo *pVoice;	long *pMix;	long oldA5;	int i;	// what the hey, we do this for the PowerPC as well	oldA5 = SetA5 (pDoubleBuffer->dbUserInfo[1]);		// compute the absolute starting time for this chunk of sound	intervalStart = AsgardESS_ComputeSoundInterval (pSound);	// if we're paused or this is the end, fill with silence	if (pSound->soundEnd || pSound->soundPaused)	{		// silence is either 0 (16-bit) or 0x80 (8-bit)		if (pSound->sixteenBit)			aess_SetLongs (pDoubleBuffer->dbSoundData, 0x00000000, (dbSize << 1) >> 2);		else			aess_SetLongs (pDoubleBuffer->dbSoundData, 0x80808080, dbSize >> 2);				// if we're ending, mark the buffer and bail		if (pSound->soundEnd)		{			pDoubleBuffer->dbFlags |= dbLastBuffer;			pSound->soundActive = false;		}	}	else	{		// zap the mix buffer		aess_SetLongs (pSound->pMixBuffer, 0, dbSize);				// loop over all voices		for (i = 0, pVoice = pSound->pVoice; i < pSound->voices; i++, pVoice++)		{			// if the voice is ready, mix it			if (pVoice->ready && pVoice->mixer)				(*pVoice->mixer)(pSound, pVoice, intervalStart);		}				// now it's time for the final mixdown		pMix = pSound->pMixBuffer;		count = dbSize;				// do the appropriate mixdown		if (pSound->mixer == AESS_MIXER_NONLINEAR)		{			if (pSound->sixteenBit)				aess_MixTo16Bit (pMix, (short *)pDoubleBuffer->dbSoundData, pSound->pMixerMiddle, count);			else				aess_MixTo8Bit (pMix, (unsigned char *)pDoubleBuffer->dbSoundData, pSound->pMixerMiddle, count);		}		else		{			if (pSound->sixteenBit)				aess_MixTo16BitLinear (pMix, (short *)pDoubleBuffer->dbSoundData, count);			else				aess_MixTo8BitLinear (pMix, (unsigned char *)pDoubleBuffer->dbSoundData, count);		}	}	// ready to go!	pDoubleBuffer->dbNumFrames = dbSize;	pDoubleBuffer->dbFlags |= dbBufferReady;	// restore A5	SetA5 (oldA5);}#pragma mark ==================== Debugging Utilities//=================================================================================================////		AsgardESS_DebugLog////		Standard printf-style debug message logger////=================================================================================================////		Inputs://			fmt = the printf format string.////=================================================================================================#if AESS_DEBUGvoid AsgardESS_DebugLog (char *fmt, ...){	if (debugindex < DEBUG_BUFFER - 256)	{		va_list ap;		va_start (ap, fmt);		debugindex += vsprintf (debugbuf + debugindex, fmt, ap);		va_end (ap);	}}#endif