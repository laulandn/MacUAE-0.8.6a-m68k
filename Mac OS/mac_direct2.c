 /*   * UAE - The Un*x Amiga Emulator  *   * Support for PowerMac  *   * Copyright 1997 Bernd Schmidt  *//*  * Things to do before next release * 8bit garbage the screen * 32bit mode broken in p96 * re-write gettimeofday using Microseconds(&time) * made my own sound code * Serial emulation slow down UAE *  * SPEED PROBLEM : 069 was 1.5 TIMES FASTER * New about box with thanx to TKR, SAJC/GDS && other * New GUI stuff for FS && serial && other stuff * re-write the keyboard stuff ( it's the only thing written by Ernesto Corvi ) * write a GUI-based debugger*//* done : * remove all the DONT_WANT_SOUND, b/c it's run-time configurable * Clean Up the code * Remove Printf && add a file for the log <- on the way*//* * changes made by !ZAJC!/GDS (Marin Saric) can be found by searching for "!ZAJC!".* buggy things can be found by searching for !BUG!*//* * Additional stuff for serial port: * 23.10.1998 Christian Kaben (TKR GmbH & Co. KG) *		This needs the Serial Tool for working. * * serial stuff for Mac: All changes marked with 'TKR'. * */#include <Timer.h>/** !ZAJC! 090798 */# include <Fonts.h># include <QuickDraw.h># include <LowMem.h># include <Sound.h># include <Gestalt.h># include <TextUtils.h># include <Devices.h># include <ToolUtils.h># include <Menus.h>#define AddResMenu(theMenu, theType) AppendResMenu(theMenu, theType)void running_pref (void);/**/#include "sysconfig.h"#include "sysdeps.h"#include "config.h"#include "options.h"#include "threaddep/penguin.h"#include "memory.h"#include "custom.h"#include "sounddep/sound.h"#include "readcpu.h"#include "newcpu.h"#include "debug.h"#include "disk.h"#include "keybuf.h"#include "uae.h"#include "xwin.h"#include "mackbd.h"#include "keyboard.h"#include "joystick.h"#include "mac.h"#include "events.h"#include "picasso96.h"#include "device.h"	// TKR/***************************************************************************/#include "Dialog Utilities.h"#include "System Utilities.h"/* #define	MW_PROFILER         */#ifdef MW_PROFILER	#include "Profiler.h"#endif/***************************************************************************//* Global Definition */static EventRecord event;static GDHandle curDevice;static WindowPtr mywin;static int bit_unit;static int keystate[256];static int screen_visible;static int FullScreen=0;static Point windowLocation;static int led_state[5];static int colors_allocated;static int refresh_necessary = 0;static int current_width, current_height;static int	repeat, old_repeat;static int mac_mouse=true;static int old_mac_mouse;int outpout_sound=1;int old_outpout_sound;long start_ticks = 0; // GetTimeOfDay HACK!/* Stuff for P96 */static long palette_entries[256][3];static int screen_is_picasso;static char picasso_invalid_lines[1201];static int picasso_has_invalid_lines;static int picasso_invalid_start, picasso_invalid_stop;static unsigned char *p96addr;/* Proto for P96 */static __inline__ void P96_flush_block(const int start_y, const int end_y);static void restore_amiga_colors (void);int lockscr (void);void unlockscr (void);uae_u8 *gfx_lock_picasso (void);void gfx_unlock_picasso (void);/* new buggy grafX stuff */static void graphics_subinit (void);static void graphics_subshutdown (void);/* Adjust WinAddr */static unsigned char *winbaseaddr;static unsigned long winrowbytes;static unsigned long lenght;/* XXX */int osd_trak_read (int axis);void ShowCursorAbsolute (void);void HideCursorAbsolute (void);void get_state(void);void set_state(void);void set_state_min(void); // -> use only in options...void myAlignWindow(WindowPtr win);#define X_AXIS 1#define Y_AXIS 2CTabHandle       myColorTable, defaultColorTable; //xxx/***************************************************************************//* Menu ID */#define kAppleMenuID			128#define kFileMenuID				129	#define kUAEReset			1	#define kUAEDebug			2	#define kUAEFreeze			3	#define kUAEQuit			5#define kEditMenuID				130#define kOptionsMenuID			131	#define kOptions			1	#define	kFullScreenMode		3	#define kEmulMouse			5#define kDrivesMenuID			132/***************************************************************************//* Check Sys 7 min */void my_check_config(void){	if ( GetSysVersion() < 7 )	ExitToShell();}/***************************************************************************//* SetUpDragRect */Rect  gDragRect;const short kDragThreshold = 30;void SetUpDragRect( void ){	gDragRect = qd.screenBits.bounds;	gDragRect.left += kDragThreshold;	gDragRect.right -= kDragThreshold;	gDragRect.bottom -= kDragThreshold;}/***************************************************************************//* AboutBox */#define kAboutBoxDlg	201#define kAboutOk		2void about_box(void){	DialogPtr		AboutDlg;	short			itemHit;	int				IsEnd;		AboutDlg = GetNewDialog( kAboutBoxDlg, NULL, (WindowPtr)(-1L) );	if ( !AboutDlg ) ExitToShell();	SetDialogDefaultItem(AboutDlg, kAboutOk);	SetDialogTracksCursor(AboutDlg, true);	itemHit = -1;	IsEnd=1;	while ( IsEnd != 666)	{	ModalDialog(NULL,&itemHit);		switch( itemHit ) { case kAboutOk: 							IsEnd=666;							break;							}	}	DisposeDialog( AboutDlg );}/***************************************************************************//* MenuBar Init */void UAE_MenuBarInit( void ){	Handle menubarHandle;	MenuHandle applemenuHandle;	if(!(menubarHandle=GetNewMBar(128))) ExitToShell();	SetMenuBar(menubarHandle);	if(!(applemenuHandle=GetMenuHandle(128))) ExitToShell();	AddResMenu(applemenuHandle,'DRVR');	/* InsertMenu(GetMenu(kJoystickMenuID), -1); */	DrawMenuBar(); }/***************************************************************************//* SIOUX init *//*void SIOUXInit( void ){	SIOUXSettings.initializeTB=false;	SIOUXSettings.standalone=false;	SIOUXSettings.setupmenus=false;	SIOUXSettings.autocloseonquit=true;	SIOUXSettings.asktosaveonclose=false;	SIOUXSettings.showstatusline=false;	SIOUXSettings.rows=11;	SIOUXSettings.toppixel=350;	SIOUXSettings.leftpixel=0;	write_log("Starting up the GUI\n");	SIOUXSetTitle("\pInfo Window");}*//***************************************************************************/static RgnHandle gOldVisRgn;static short gOldMBarHeight;/* HideMenuBar */void UAE_HideMenuBar(GrafPtr grafPort){	Rect	menuRect={0,0,20,640};	RgnHandle newVisRgn;	GrafPtr savePort;		GetPort(&savePort);	SetPort(grafPort);	gOldVisRgn = NewRgn();	CopyRgn(grafPort->visRgn, gOldVisRgn);	newVisRgn = NewRgn();	RectRgn(newVisRgn, &grafPort->portRect);	CopyRgn(newVisRgn, grafPort->visRgn);	DisposeRgn(newVisRgn);	PaintRect(&menuRect);	gOldMBarHeight = GetMBarHeight();	LMSetMBarHeight(0);	SetPort(savePort);}/***************************************************************************//* ShowMenuBar */void UAE_ShowMenuBar(GrafPtr grafPort){	GrafPtr savePort;	RgnHandle junkRgn;	GetPort(&savePort);	SetPort(grafPort);	junkRgn = NewRgn();	CopyRgn(gOldVisRgn, junkRgn);	DiffRgn(grafPort->visRgn, junkRgn, junkRgn);	FillRgn(junkRgn, &qd.black);	DisposeRgn(junkRgn);	CopyRgn(gOldVisRgn, grafPort->visRgn);	DisposeRgn(gOldVisRgn);	gOldVisRgn = NULL;	LMSetMBarHeight(gOldMBarHeight);	DrawMenuBar();}/***************************************************************************/static int trak_active;int osd_trak_read (int axis){	Point 		*RawMouse	= (Point*) 0x82C;	Point 		*MTemp		= (Point*) 0x828;	Ptr    		CrsrNew		= (Ptr)    0x8CE;	Ptr    		CrsrCouple 	= (Ptr)    0x8CF;	static int	mouse_x	= 0;	static int	mouse_y	= 0;	int			temp_x, temp_y;	int			res = 0;  	trak_active = true;		switch (axis)	{		case X_AXIS:			temp_x = RawMouse->h;			res = temp_x - mouse_x;			mouse_x = temp_x;								/* "wrap" mouse around the edges of the screen */			if (mouse_x < 32)			{				RawMouse->h = MTemp->h = mouse_x = qd.screenBits.bounds.right-32;				*CrsrNew = *CrsrCouple;			}			else if (mouse_x > (qd.screenBits.bounds.right-32) )			{				RawMouse->h = MTemp->h = mouse_x = 32;				*CrsrNew = *CrsrCouple;			}			break;		case Y_AXIS:			temp_y = RawMouse->v;			res = temp_y - mouse_y;			mouse_y = temp_y;			/* "wrap" mouse around the edges of the screen */			if (mouse_y < 32)			{				RawMouse->v = MTemp->v = mouse_y = qd.screenBits.bounds.bottom-32;				*CrsrNew = *CrsrCouple;			}			else if (mouse_y > (qd.screenBits.bounds.bottom-32) )			{				RawMouse->v = MTemp->v = mouse_y = 32;				*CrsrNew = *CrsrCouple;			}			break;	}	return res;	}/***************************************************************************/void ShowCursorAbsolute (void){	ShowCursor ();	mac_mouse = true;}/***************************************************************************/void HideCursorAbsolute (void){	HideCursor ();	mac_mouse = false;}/***************************************************************************/void ShowArrowCursor(void){	SetCursor(&qd.arrow);} /***************************************************************************/static int check_full_screen(void){	int i;	int largeur=(*curDevice)->gdRect.right-(*curDevice)->gdRect.left;	int hauteur=(*curDevice)->gdRect.bottom-(*curDevice)->gdRect.top;	if ((current_width!=largeur)||(current_height!=hauteur)) i=0;	else i=1;	return i;}/***************************************************************************/static FILE *debugfile = NULL;char debugfilename[128];int graphics_setup(){//	printf("GETTIMEOFDAY HACK\n");	start_ticks=TickCount();		sprintf( debugfilename, "winuaelogs.txt" );    debugfile = fopen( debugfilename, "wt" );	return 1;}/***************************************************************************/int graphics_init(){	int i;	Rect	windowRectangle;	int largeur, hauteur;	char	szStr[40];		curDevice = GetMainDevice();		largeur=(*curDevice)->gdRect.right-(*curDevice)->gdRect.left;	hauteur=(*curDevice)->gdRect.bottom-(*curDevice)->gdRect.top;	write_log("Main Screen : %d x %d\n",largeur,hauteur);    fixup_prefs_dimensions (&currprefs);	if (currprefs.gfx_height > hauteur) currprefs.gfx_height = hauteur;	if (currprefs.gfx_width > largeur) currprefs.gfx_width = largeur;	SetRect(&windowRectangle,0,40,currprefs.gfx_width,currprefs.gfx_height+40);		gfxvidinfo.maxblocklines= 0;	bit_unit=((*(*curDevice)->gdPMap)->pixelSize);	gfxvidinfo.pixbytes=bit_unit >> 3;    gfxvidinfo.width=currprefs.gfx_width;    gfxvidinfo.height=currprefs.gfx_height;	gfxvidinfo.rowbytes=currprefs.gfx_width*gfxvidinfo.pixbytes;	current_width = currprefs.gfx_width;    current_height = currprefs.gfx_height;	write_log("Starting UAE in %d x %d, in %d bpp\n",				currprefs.gfx_width,				currprefs.gfx_height,				(gfxvidinfo.pixbytes)*8);	sprintf (szStr,"The Ultimate Amiga Emulator v0.8.6");	mywin = NewCWindow(nil, &windowRectangle, c2pstr(szStr), 1, 4, (WindowPtr)-1L, 0, 0);	myAlignWindow(mywin);		SetPort(mywin);	windowLocation.h = -(**(((CGrafPtr) mywin)->portPixMap)).bounds.left;	windowLocation.v = -(**(((CGrafPtr) mywin)->portPixMap)).bounds.top;	gfxvidinfo.bufmem=(char *)xmalloc((currprefs.gfx_height)*(currprefs.gfx_width*gfxvidinfo.pixbytes));	memset(gfxvidinfo.bufmem,0x0,(currprefs.gfx_height)*(currprefs.gfx_width*gfxvidinfo.pixbytes));	gfxvidinfo.linemem=NULL;	gfxvidinfo.emergmem=NULL;if ( bit_unit == 8){ // xxx	PaletteHandle tempPalette = NewPalette( 256, nil, pmExplicit | pmTolerant, 0 );				   	myColorTable = (CTabHandle) NewHandleClear( sizeof(ColorTable) - sizeof(ColorSpec) );	Palette2CTab( tempPalette, myColorTable );	DisposePalette( tempPalette );		defaultColorTable = GetCTable( 8 ); // default colors} //xxx    init_colors();		screen_is_picasso = 0;	#ifdef PICASSO96	if (currprefs.gfxmem_size) { 	p96addr=xmalloc(currprefs.gfxmem_size);	if (p96addr) memset(p96addr,0x0,currprefs.gfxmem_size);	}#endif /* P96 */	graphics_subinit();		buttonstate[0] = buttonstate[1] = buttonstate[2] = 0;	for(i=0; i<256; i++) keystate[i] = 0;	lastmx = lastmy = 0;		newmousecounters=0;	screen_visible=1;#ifdef MW_PROFILER	{	long tmp;	tmp=ProfilerInit(collectDetailed,bestTimeBase,200,10);	}#endif	return 1;}/***************************************************************************/static void graphics_subinit (void){	SizeWindow(mywin,current_width,current_height,true);	if (FullScreen) FullScreenMode();	AdjustMenus(); 	MoveWindow(mywin,0,40,1);	AdjustWinAddr();    DX_SetPalette (0, 256);    if (screen_is_picasso) {    	picasso_vidinfo.rowbytes = current_width * picasso_vidinfo.pixbytes; // ??    	picasso_vidinfo.extra_mem = 1;		picasso_has_invalid_lines = 0;		picasso_invalid_start = picasso_vidinfo.height + 1;		picasso_invalid_stop = -1;		memset (picasso_invalid_lines, 0, sizeof picasso_invalid_lines);    }}/***************************************************************************/// had to use this one to clean up, perhaps CLUT ???static void graphics_subshutdown (void){if ( bit_unit == 8) SetEntries( 0, 255, (**defaultColorTable).ctTable );}/***************************************************************************/// !BUG! what's gfx_afullscreen and gfx_pfullscreen ??// Not used on this port !!int check_prefs_changed_gfx (void){    if (changed_prefs.gfx_width != currprefs.gfx_width	|| changed_prefs.gfx_height != currprefs.gfx_height)	fixup_prefs_dimensions (&changed_prefs);    if (changed_prefs.gfx_width == currprefs.gfx_width	&& changed_prefs.gfx_height == currprefs.gfx_height	&& changed_prefs.gfx_lores == currprefs.gfx_lores	&& changed_prefs.gfx_linedbl == currprefs.gfx_linedbl	&& changed_prefs.gfx_correct_aspect == currprefs.gfx_correct_aspect	&& changed_prefs.gfx_xcenter == currprefs.gfx_xcenter	&& changed_prefs.gfx_ycenter == currprefs.gfx_ycenter	&& changed_prefs.gfx_afullscreen == currprefs.gfx_afullscreen	&& changed_prefs.gfx_pfullscreen == currprefs.gfx_pfullscreen)	return 0;        return 0;}/***************************************************************************/int lockscr (void){    return 1;}/***************************************************************************/void unlockscr (void){}/***************************************************************************/void graphics_leave(){#if MW_PROFILER	ProfilerDump((unsigned char *)"\pmyProf");	ProfilerTerm();#endif    graphics_subshutdown ();    	fclose( debugfile );	ShowCursorAbsolute();	FlushEvents (everyEvent,0);	DisposeWindow(mywin);	DisposePtr((Ptr)(gfxvidinfo.bufmem));}/***************************************************************************//* 23/06/97                                     */void AdjustWinAddr( void ){	PixMapHandle	ph;			ph=GetGWorldPixMap((CGrafPort *) mywin);	#define TOO_LEFT 	((-1*(*ph)->bounds.left)<((*curDevice)->gdRect.left))	#define	TOO_RIGHT	(((-1*(*ph)->bounds.left)+current_width)>((*curDevice)->gdRect.right))	#define	TOO_HIGH	((-1*(*ph)->bounds.top)<((*curDevice)->gdRect.top))	#define TOO_LOW		(((-1*(*ph)->bounds.top)+current_height)>(*curDevice)->gdRect.bottom)	if (TOO_LEFT || TOO_RIGHT || TOO_HIGH || TOO_LOW ) {			SysBeep(20);			MoveWindow(mywin,windowLocation.h,windowLocation.v,1);			ph=GetGWorldPixMap((CGrafPort *) mywin);			}	winbaseaddr=( unsigned char *) GetPixBaseAddr(ph);	winrowbytes=(*ph)->rowBytes & 0x3FFF;	winbaseaddr-=((**ph).bounds.left)*gfxvidinfo.pixbytes;	winbaseaddr-=(((**ph).bounds.top)*winrowbytes);	lenght=((current_width*gfxvidinfo.pixbytes)/sizeof(double));}/***************************************************************************/void myAlignWindow(WindowPtr win){	GDHandle device;	Point z;	long h, v;	device = GetMainDevice();	h = (*win).portRect.right - (*win).portRect.left;	v = (*win).portRect.bottom - (*win).portRect.top;	SetGWorld((GWorldPtr) win, nil);	z.h = z.v = 0;	LocalToGlobal(&z);	z.h &= 0xFFF8;	//if (z.h < (*device)->gdRect.left + 8) z.h = (*device)->gdRect.left + 8;	//	else if ((z.h + h) > (*device)->gdRect.right - 8) z.h = (*device)->gdRect.right - h - 8;	//if (z.v < (*device)->gdRect.top + 40) z.v = (*device)->gdRect.top + 40;	//	else if ((z.v + v) > (*device)->gdRect.bottom - 8) z.v = (*device)->gdRect.bottom - v - 8;	MoveWindow(win, z.h, z.v, true);	SetGWorld(nil, device);}/***************************************************************************/void flush_screen (int a, int b){	/* None */}/***************************************************************************/void flush_line(const int y){	double *src,*dest;	double *unrollSrc, *unrollDest, unroll0, unroll1;	unsigned long x, len;		if (!screen_visible) return;		dest=(double *)(winbaseaddr+(y*winrowbytes));	src=(double *)(gfxvidinfo.bufmem+(y*gfxvidinfo.rowbytes));	unrollSrc = src-2; unrollDest = dest-2;				/* !ZAJC! 160498 */    --src; --dest;										/* !ZAJC! 160498 */	for (len=lenght>>1,x=0;x<len;++x)					/* !ZAJC! 010298 */	{		unroll0 = *(src+=2); unroll1 = *(unrollSrc+=2);  /* !ZAJC! 160498 */		*(dest+=2) = unroll0; *(unrollDest+=2) = unroll1;/* !ZAJC! 160498 */	}		}/***************************************************************************/void flush_block (const int start_y, const int end_y){	/* none */}/***************************************************************************/void gui_fps( int fps ){	// printf("FPS: %2u\n", fps);}/***************************************************************************/void redraw_screen(void){	int conteur,local;	for (conteur=0,local=currprefs.gfx_height;		conteur<local;		flush_line(conteur),++conteur) {}			refresh_necessary = 0; // ???}/***************************************************************************/static void restore_amiga_colors (void){    int i;    if (gfxvidinfo.pixbytes != 1)	return;    for (i = 0; i < 256; i++)	my_setpalette (i, palette_entries[i][0], palette_entries[i][1], palette_entries[i][2]);}/***************************************************************************/static int get_color(int r, int g, int b, xcolnr *cnp){		if (colors_allocated == 256) return -1;	*cnp = colors_allocated;		palette_entries[colors_allocated][0] = doMask(r, 6, 0);    palette_entries[colors_allocated][1] = doMask(g, 6, 0);    palette_entries[colors_allocated][2] = doMask(b, 6, 0);	my_setpalette(colors_allocated, doMask(r, 6, 0), doMask(g, 6, 0), doMask(b, 6, 0));	colors_allocated++;	return 1;}/***************************************************************************/void init_colors(void){	int rw = 5, gw = 5, bw = 5;			switch (gfxvidinfo.pixbytes) {	 case 4:		alloc_colors64k(8,8,8,16,8,0);		break;	 case 2:		alloc_colors64k(5,5,5,10,5,0);		break;	 case 1:		alloc_colors256(get_color);		break;	 default:		abort();	}	gfxvidinfo.can_double = 0;	 }/***************************************************************************//* !ATB! Seems to work, but I got STrANGE result at exit ! *//* V 0.30 *//* !BUG! : stange result at exit, and too slow :( */void my_setpalette(int count, unsigned short r, unsigned short g, unsigned short b){/*	GDHandle dev = curDevice;	CTabHandle srcTab = (**(**dev).gdPMap).pmTable;	GDHandle oldDevice = GetGDevice();		SetGDevice(dev);	(**srcTab).ctTable[count].rgb.red = r<<10;	(**srcTab).ctTable[count].rgb.green = g<<10;	(**srcTab).ctTable[count].rgb.blue = b<<10;	SetEntries(0, (**srcTab).ctSize, (ColorSpec *)&(**srcTab).ctTable);	MakeITable(nil, nil, 0);	SetGDevice(oldDevice);*/	(**myColorTable).ctTable[count].rgb.red   = r<<10; 	(**myColorTable).ctTable[count].rgb.green = g<<10;	(**myColorTable).ctTable[count].rgb.blue  = b<<10;	SetEntries( 0, 255, (ColorSpec *)&(**myColorTable).ctTable ); 	MakeITable(nil, nil, 0);}/***************************************************************************/// # == AK_NUMBERSIGN;// \ == AK_BACKSLASH;// !BUG! # is non-working on some? keyboard#define kF13KeyMap					0x69#define kF14KeyMap					0x6B#define kF15KeyMap					0x71static __inline__ int kc_decode (long ks){		switch (ks)	{	 case kAKeyMap: return AK_A;	 case kBKeyMap: return AK_B;	 case kCKeyMap: return AK_C;	 case kDKeyMap: return AK_D;	 case kEKeyMap: return AK_E;	 case kFKeyMap: return AK_F;	 case kGKeyMap: return AK_G;	 case kHKeyMap: return AK_H;	 case kIKeyMap: return AK_I;	 case kJKeyMap: return AK_J;	 case kKKeyMap: return AK_K;	 case kLKeyMap: return AK_L;	 case kMKeyMap: return AK_M;	 case kNKeyMap: return AK_N;	 case kOKeyMap: return AK_O;	 case kPKeyMap: return AK_P;	 case kQKeyMap: return AK_Q;	 case kRKeyMap: return AK_R;	 case kSKeyMap: return AK_S;	 case kTKeyMap: return AK_T;	 case kUKeyMap: return AK_U;	 case kVKeyMap: return AK_V;	 case kWKeyMap: return AK_W;	 case kXKeyMap: return AK_X;	 	 case k0KeyMap: return AK_0;	 case k1KeyMap: return AK_1;	 case k2KeyMap: return AK_2;	 case k3KeyMap: return AK_3;	 case k4KeyMap: return AK_4;	 case k5KeyMap: return AK_5;	 case k6KeyMap: return AK_6;	 case k7KeyMap: return AK_7;	 case k8KeyMap: return AK_8;	 case k9KeyMap: return AK_9;	 	 case kKP0KeyMap: return AK_NP0;	 case kKP1KeyMap: return AK_NP1;	 case kKP2KeyMap: return AK_NP2;	 case kKP3KeyMap: return AK_NP3;	 case kKP4KeyMap: return AK_NP4;	 case kKP5KeyMap: return AK_NP5;	 case kKP6KeyMap: return AK_NP6;	 case kKP7KeyMap: return AK_NP7;	 case kKP8KeyMap: return AK_NP8;	 case kKP9KeyMap: return AK_NP9;		 case kF1KeyMap: return AK_F1;	 case kF2KeyMap: return AK_F2;	 case kF3KeyMap: return AK_F3;	 case kF4KeyMap: return AK_F4;	 case kF5KeyMap: return AK_F5;	 case kF6KeyMap: return AK_F6;	 case kF7KeyMap: return AK_F7;	 case kF8KeyMap: return AK_F8;	 case kF9KeyMap: return AK_F9;	 case kF10KeyMap: return AK_F10;	 	 case kF14KeyMap: return AK_inhibit;	 case kF13KeyMap: return AK_mousestuff;	 	 case kBackSpaceKeyMap: return AK_BS;	 case kTabKeyMap: return AK_TAB;	 case kReturnKeyMap: return AK_RET;	 case kEscapeKeyMap: return AK_ESC;	 	 case kSpaceBarMap:	 return AK_SPC;	 	 case kUpArrowKeyMap: return AK_UP;	 case kDownArrowKeyMap: return AK_DN;	 case kLeftArrowKeyMap: return AK_LF;	 case kRightArrowKeyMap: return AK_RT;		 case kPgUpKeyMap: return AK_RAMI;	 case kPgDnKeyMap: return AK_LAMI;	/* US specific */	 case kYKeyMap:			return AK_Y;	 case kZKeyMap:			return AK_Z;	 case kLBracketKeyMap:	return AK_LBRACKET;	 case kRBracketKeyMap:	return AK_RBRACKET;	 case kCommaKeyMap:		return AK_COMMA;	 case kPeriodKeyMap:	return AK_PERIOD;	 case kSlashKeyMap:		return AK_SLASH;	 case kSemiColonKeyMap: return AK_SEMICOLON;	 case kMinusKeyMap:		return AK_MINUS;	 case kEqualKeyMap:		return AK_EQUAL;	 case kQuoteKeyMap:		return AK_QUOTE;	 case 75	 : return AK_NPDIV ;	 case 67	 : return AK_NPMUL ;	 case 78	 : return AK_NPSUB ;	 case 69	 : return AK_NPADD ;	 case 71	 : return AK_NPDEL ;	 case 76	 : return AK_ENT   ;	 case 117 	 : return AK_DEL   ;	 case 115	 : return AK_RSH   ;	 case 119	 : return AK_RALT  ;	 case 114	 : return AK_HELP  ;	 //	 case 10     : return AK_NUMBERSIGN;	}	return -1;}/***************************************************************************/static __inline__ int keycode2amiga(long code){	long ks;	int as;		ks = (code & keyCodeMask) >> 8;//	printf("KeyBoard : %d\n",ks);	as = kc_decode (ks);		return as;}/***************************************************************************/void  handle_my_keys(void){	KeyMap keys;		GetKeys(keys);	if (BitTst(&keys, kCommandRawKey))	buttonstate[2] = 1;	else	buttonstate[2] = 0;		if (BitTst(&keys, kShiftRawKey))	{		if (!keystate[AK_LSH]) {		keystate[AK_LSH] = 1;		record_key (AK_LSH << 1);		goto label1;	}	} else {	if (keystate[AK_LSH]) {		keystate[AK_LSH] = 0;		record_key ((AK_LSH << 1) | 1);		goto label1;	}	}	if (BitTst(&keys, kControlRawKey))	{		if (!keystate[AK_CTRL]) {		keystate[AK_CTRL] = 1;		record_key (AK_CTRL << 1);		goto label1;	}	} else {		if (keystate[AK_CTRL]) {		keystate[AK_CTRL] = 0;		record_key ((AK_CTRL << 1) | 1);		goto label1;	}	}	if (BitTst(&keys, kCapsRawKey))	{		if (!keystate[AK_CAPSLOCK]) {		keystate[AK_CAPSLOCK] = 1;		record_key (AK_CAPSLOCK << 1);		goto label1;	}	} else {	if (keystate[AK_CAPSLOCK]) {		keystate[AK_CAPSLOCK] = 0;		record_key ((AK_CAPSLOCK << 1) | 1);		goto label1;	}	}	if (BitTst(&keys, kOptionRawKey))	{		if (!keystate[AK_LALT]) {		keystate[AK_LALT] = 1;		record_key (AK_LALT << 1);		goto label1;	}	} else {	if (keystate[AK_LALT]) {		keystate[AK_LALT] = 0;		record_key ((AK_LALT << 1) | 1);		goto label1;	}	}label1:	/* "Affengriff" */	if(keystate[AK_CTRL] && keystate[AK_LAMI] && keystate[AK_RAMI])		uae_reset();}/***************************************************************************/void  handle_my_mouse(void){		if (mac_mouse) return;				lastmx+=osd_trak_read(X_AXIS);		lastmy+=osd_trak_read(Y_AXIS);		newmousecounters=0;}/***************************************************************************/void get_state(void){	refresh_necessary=1;	screen_visible=0;	old_mac_mouse=mac_mouse;	if (!mac_mouse) ShowCursorAbsolute();	ShowArrowCursor();		old_outpout_sound=outpout_sound;	AsgardESS_Pause(true);	old_repeat=repeat;	repeat=1;	//	Restore the palette to Mac default.if( bit_unit == 8 ) SetEntries( 0, 255, (**defaultColorTable).ctTable ); // xxx}/***************************************************************************/void set_state(void){	refresh_necessary=1;	screen_visible=1;	mac_mouse=old_mac_mouse;	if (mac_mouse) {		ShowCursorAbsolute();		ShowArrowCursor();	} else HideCursorAbsolute();	outpout_sound=old_outpout_sound;	if (!outpout_sound) AsgardESS_Pause(true);	else AsgardESS_Pause(false);	repeat=old_repeat;	// Restore the palette to Amiga defaultif ( bit_unit == 8 ) SetEntries( 0, 255, (**myColorTable).ctTable ); // xxx}/***************************************************************************/void set_state_min(void){	refresh_necessary=1;	screen_visible=1;	mac_mouse=old_mac_mouse;	if (mac_mouse) {		ShowCursorAbsolute();		ShowArrowCursor();	} else HideCursorAbsolute();	repeat=old_repeat;// Restore the palette to Amiga defaultif ( bit_unit == 8 ) SetEntries( 0, 255, (**myColorTable).ctTable ); // xxx}/***************************************************************************/static unsigned int newt, oldt;void handle_events(){	int			kc;	GrafPtr		oldSave;	WindowPtr	w;	int			ret;		newt++;	if ( (newt-oldt) == 2 ) {	oldt=newt; 	do {		if ((FullScreen)||(!mac_mouse)) ret=GetOSEvent( everyEvent, &event );		else ret=WaitNextEvent(everyEvent,&event,0L,0L);	if (ret){	switch(event.what) {			case updateEvt:			if( !IsDAWindow_( (WindowPtr)event.message ) )			{	w = (WindowPtr)event.message;				GetPort( &oldSave );				SetPort( w );				BeginUpdate( w );				refresh_necessary = 1;				EndUpdate( w );				SetPort( oldSave);			}			break;				 case keyDown:	 case autoKey: {		 if ((event.modifiers & cmdKey) != 0)		 	HandleMenu(MenuKey((char) (event.message & charCodeMask)));		 else		 {	int kc = keycode2amiga(event.message);			if (kc == -1) break;			 switch (kc) {					case AK_mousestuff:					togglemouse();				break;						case AK_inhibit:					toggle_inhibit_frame (0);				break;				default:					 if (!keystate[kc]) {					 	keystate[kc] = 1;						record_key (kc << 1);					 	} break; /* default */			 } break; /* kc */		}	 } break;/* autoKey */	 	 case keyUp: kc = keycode2amiga(event.message);		 		 if (kc == -1) break;		 		 keystate[kc] = 0;		 		 record_key ((kc << 1) | 1);			break;				 	case mouseDown:			if (!mac_mouse) {				buttonstate[0] = 1;			} else {			DoMouseDown();			}		break;	case osEvt:			if (event.message & 0x01000000 ) {			if (event.message & 0x00000001 ) {				/* Go to ForeGround */				set_state();			} else {				/* Go in the BackGround */				/* repeat = 1; Freeze */				get_state();			}		}		break; 	 case mouseUp:		buttonstate[0] = 0;		buttonstate[2] = 0;		break;	}//	if (mac_mouse) SIOUXHandleOneEvent(&event); // !BUG!	}	handle_my_keys();	handle_my_mouse();	} while (repeat);#ifdef PICASSO96	if (screen_is_picasso && refresh_necessary) {		P96_flush_block(0,picasso_vidinfo.height);	    refresh_necessary = 0;	    memset (picasso_invalid_lines, 0, sizeof picasso_invalid_lines);	} else if (screen_is_picasso && picasso_has_invalid_lines) {	    int i;	    int strt = -1;	    picasso_invalid_lines[picasso_vidinfo.height] = 0;	    for (i = picasso_invalid_start; i < picasso_invalid_stop + 2; i++) {		if (picasso_invalid_lines[i]) {		    picasso_invalid_lines[i] = 0;		    if (strt != -1)			continue;		    strt = i;		} else {		    if (strt == -1)			continue;			{				P96_flush_block(strt, i);				//printf("P96_flush_block : %d -> %d\n",(strt), (i-strt));			}		    strt = -1;		}	    }	    if (strt != -1)		abort ();	}    picasso_has_invalid_lines = 0;    picasso_invalid_start = picasso_vidinfo.height + 1;    picasso_invalid_stop = -1;#endif    	if (! screen_is_picasso && refresh_necessary) {		redraw_screen(); 	    refresh_necessary = 0;	}  }}/***************************************************************************/void HandleMenu (long mSelect){	short		menuID;	short		menuItem;	Str255		name;	int			backup=0;	int			accNumber;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	if (menuID == 0) return ;	switch (menuID)	{	case kAppleMenuID:			switch (menuItem)			{	case 1:					get_state();					about_box();					set_state();				break;				default:					GetMenuItemText(GetMenuHandle(kAppleMenuID),menuItem,name);					accNumber=OpenDeskAcc(name);				break;			}			break;		case kFileMenuID:			switch (menuItem)			{	case kUAEReset:					uae_reset();				break;													case kUAEDebug:					if(repeat) repeat^=1; /* UnFreeze */					activate_debugger();				break;								case kUAEFreeze:					repeat^=1; /* Freeze the emulator */				break;				case kUAEQuit: 					if(repeat) repeat^=1; /* UnFreeze */					if (FullScreen) {						UAE_ShowMenuBar(mywin);						MoveWindow(mywin,0,40,1);					}					uae_quit();				break;								default:break;			}			break;					case kOptionsMenuID:			switch (menuItem) {				case kOptions : get_state(); running_pref(); set_state_min(); break;				case kFullScreenMode : FullScreenMode(); break;				case kEmulMouse: if (mac_mouse) HideCursorAbsolute();						else ShowCursorAbsolute(); break;				default : break;				}			break;			case kDrivesMenuID:			get_state();			if (menuItem >= 1 && menuItem <= 4)			{	if (disk_empty(menuItem-1))					{	StandardFileReply		inputReply;						StandardGetFile(nil,-1L,nil,&inputReply);						if (inputReply.sfGood)						{	char name[256];							GetFullPath(inputReply.sfFile.parID,										inputReply.sfFile.vRefNum,										(char *) inputReply.sfFile.name,										name);							disk_insert (menuItem-1,name); }						} else {						disk_eject(menuItem-1);					}									}			AdjustDiskMenu();			set_state();			break;	}	HiliteMenu(0);}/***************************************************************************/void AdjustDiskMenu(void){/* DF0 */	if (disk_empty(0)) {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 1, "\pInsert Disk in DF0:");	} else {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 1, "\pEject Disk in DF0:"); }/* DF1 */	if (disk_empty(1)) {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 2, "\pInsert Disk in DF1:");	} else {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 2, "\pEject Disk in DF1:"); }/* DF2 */	if (disk_empty(2)) {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 3, "\pInsert Disk in DF2:");	} else {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 3, "\pEject Disk in DF2:"); }/* DF3 */	if (disk_empty(3)) {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 4, "\pInsert Disk in DF3:");	} else {	SetMenuItemText(GetMenuHandle(kDrivesMenuID), 4, "\pEject Disk in DF3:"); }}/***************************************************************************/void AdjustMenus(void){	if (check_full_screen()==0) DisableItem(GetMenuHandle(kOptionsMenuID),3);	else EnableItem(GetMenuHandle(kOptionsMenuID),3);}/***************************************************************************/void DoMouseDown( void ){	WindowPtr	w;	short int	thePart;	long int	menuChoice;	   		thePart = FindWindow( event.where, &w );	switch( thePart )	{		case inMenuBar:			AdjustMenus();			menuChoice = MenuSelect( event.where );			HandleMenu( menuChoice );			break;					case inSysWindow: 			SystemClick( &event, w );			break;					case inContent:			if( w != FrontWindow() ) SelectWindow( w );			break;					case inDrag: 			windowLocation.h = -(**(((CGrafPtr) w)->portPixMap)).bounds.left;			windowLocation.v = -(**(((CGrafPtr) w)->portPixMap)).bounds.top;			DragWindow(w, event.where, &gDragRect);			myAlignWindow(w);			AdjustWinAddr();			break;	}}/***************************************************************************/void FullScreenMode(void){	FullScreen ^= 1;	if (FullScreen)		{				MoveWindow(mywin,0,0,1);			UAE_HideMenuBar(mywin);		} else {			UAE_ShowMenuBar(mywin);			MoveWindow(mywin,0,40,1);		}		myAlignWindow(mywin);		AdjustWinAddr();		refresh_necessary = 1;}/***************************************************************************/int debuggable(void){	return 1;}/***************************************************************************/int needmousehack(void){	return 0;}/***************************************************************************/void LED(int on){}/***************************************************************************/#if 0void write_log (const char *buf,...){	printf (buf);}#else#define WRITE_LOG_BUF_SIZE 1024void write_log (const char *format,...){    long numwritten;    char buffer[12];    va_list parms;    int count = 0;    int *blah = (int *)0xdeadbeef;    if( debugfile )    {#if defined HAVE_GETTIMEOFDAY && defined TIMESTAMP_LOGS        {            struct timeval tv;            gettimeofday(&tv,NULL);            sprintf( buffer, "%4d:%3d - ", tv.tv_sec, tv.tv_usec/1000 );            fprintf( debugfile, buffer );        }#endif        va_start (parms, format);        count = vfprintf( debugfile, format, parms );        fflush( debugfile );        if( count >= WRITE_LOG_BUF_SIZE-1 )        {            fprintf( debugfile, "SHIT in write_log()\n" );            fflush( debugfile );            *blah = 0; /* Access Violation here! */            abort();        }        va_end (parms);    }}#endif/***************************************************************************/void setup_brkhandler( void ){}/***************************************************************************/int gui_init(void){	UAE_MenuBarInit();//	SIOUXInit();	SetUpDragRect();	write_log("\n		Un*x Amiga Emulator V%d.%d.%d\n"				"		   by Bernd Schmidt\n\n" , UAEMAJOR, UAEMINOR, UAESUBREV);	return 1;}/***************************************************************************/int gui_update(void){	return 0;}/***************************************************************************/void gui_led(int led, int on){	led_state[led]=on;}/***************************************************************************/void gui_filename(int num, const char *name){#if 0	printf("drivename  %d ",num);	if (name[0] == 0) name = "(none)";	printf("%s\n", name);#endif	AdjustDiskMenu();}/***************************************************************************/static void save_settings (void){	extern char optionsfile[256];    FILE *f;    f = fopen (optionsfile, "w");    if (f == NULL) {	write_log("Error saving options file!\n");	return;    }    save_options (f);    fclose (f);}/***************************************************************************/void gui_exit(){	save_settings();	ShowCursorAbsolute();	FlushEvents(keyDown | keyUp | autoKey | mouseDown | mouseUp,0);}/***************************************************************************/// micro == 10e-6void gettimeofday(struct timeval *tv,int dummy){    long ticks = TickCount() - start_ticks;    tv->tv_sec = ticks/60;    tv->tv_usec = (ticks-(tv->tv_sec*60))*60; // BUGS ???}/***************************************************************************//* Possible options for the "50" are 50, 60, sync from monitor, or * no sync (Fellow's 'unlimited' option, bad for sound!)  * Note that vsync_handler is called regardless of framerate, so we * don't need to account for the framerate in this function.  * * This function can be improved by checking for the sync that the Amiga * expects to have.*/static UnsignedWide prevEndFrameTime, switchTime; // !ZAJC! 260998static unsigned long frameTime = 1000000 / 50;static UnsignedWide uwFrameTime;/* !ZAJC!'s modification of synchro routines	specs: 50hz Amigastyle sync, PowerPC only,			compatibile with every PowerPC..	description: uv_add & uv_sub do + and - operations with				 ultrawide units.				 				 prevEndFrameTime remains, it designates				 the end time  of last frame in microseconds..				 switchTime is the time when next vertical blank should occur..				 the vsync_handler tests whether current time is greater				 than difference of the switchTime and prevEndFrameTime,				 i.e. whether current time got past the switchTime..				 if that is true, next VBL is scheduled for 				 switchTime+1000000/50 microseconds, while current time				 is recorded as prevEndFrameTime...				 				 Notice that next VBL will not occur 1/50 seconds after				 prevEndFrameTime, but 1/50 seconds after switchTime,				 that way, the correction of errors is implemented.				 (prevEndFrameTime is probably greater than last switchtime,				  so (like in the previous implementation) vertical blanks				  would not occur uniformly.				  				  if there is a time lag (finder tries to do something,				  or VM activates or loading process takes a while), 				  vsync_handler will try to "fast forward" the execution				  of the rest of emulator, except if the lag is greater than				  1/25 seconds.*/	void uv_sub (int lo1, int lo2, int hi1, int hi2, int *rlo, int *rhi);void uv_add (int lo1, int lo2, int hi1, int hi2, int *rlo, int *rhi);void init_mac_vsync (void);void mac_vsync(void);/////////////////// UnsignedWide add & sub, by !ZAJC! //// NICKL added dumb C versions so can run on m68k macs...#if __POWERPC__inline asm void uv_sub (int lo1, int lo2, int hi1, int hi2, int *rlo, int *rhi){//						r3		r4			r5		r6		r7			r8	subfco r3,r4,r3	subfe  r5,r6,r5	stw r3, 0(r7)	stw r5, 0(r8)	blr}#elseinline void uv_sub (int lo1, int lo2, int hi1, int hi2, int *rlo, int *rhi){  lo1-=lo2;  hi1-=hi2;  rlo[0]=lo1;  rhi[0]=hi1;}#endif#if __POWERPC__inline asm void uv_add (int lo1, int lo2, int hi1, int hi2, int *rlo, int *rhi){//						r3		r4			r5		r6		r7			r8	addco r3,r4,r3	adde  r5,r6,r5	stw r3, 0(r7)	stw r5, 0(r8)	blr}#elseinline void uv_add (int lo1, int lo2, int hi1, int hi2, int *rlo, int *rhi){  lo1+=lo2;  hi1+=hi2;  rlo[0]=lo1;  rhi[0]=hi1;}#endif////////////////////////////////////////////////////////void init_mac_vsync (void){	// ++++ nifty vsync init code.. must execute @ startup ++++	uwFrameTime.hi=0; uwFrameTime.lo=frameTime;	Microseconds (&prevEndFrameTime);	uv_add (prevEndFrameTime.lo, uwFrameTime.lo, prevEndFrameTime.hi, 0, &(switchTime.lo), &(switchTime.hi));}void mac_vsync(void){#if 0 // !ZAJC! 250998	UnsignedWide time;	Microseconds (&time);	while (time.lo - prevEndFrameTime.lo < frameTime)		Microseconds (&time);	prevEndFrameTime = time;#else /* !ZAJC!'s synchro code */	UnsignedWide time,delta,z=prevEndFrameTime,q=switchTime,delta2;		// means delta2 = switchTime-prevEndFrameTime	uv_sub(q.lo,z.lo,q.hi,z.hi,&(delta2.lo),&(delta2.hi));	Microseconds (&time);	for (;;)	{		uv_sub (time.lo, z.lo, time.hi, z.hi, &(delta.lo), &(delta.hi));		if ((delta.hi) || (delta.lo>=delta2.lo)) break; // means if time>switchTime break;		Microseconds (&time);	}	if ((delta.hi) || (delta.lo>40000)) {		init_mac_vsync(); // if lag greater than 1/25 sec..						  // reset counter	}	else // if no lag, continue... if small lag, it'll try to catchup (fast forward)...	{		prevEndFrameTime=z;		uv_add (switchTime.lo, uwFrameTime.lo, switchTime.hi, 0, &(switchTime.lo), &(switchTime.hi));	}#endif}/***************************************************************************//* I need to put all this in a separate module *//*	bpp			4		2red_bits		8		5green_bits		8		5blue_bits		8		5red_shift		16		10green_shift		8		5blue_shift		0		0  *//* "what a mess" - Duke Nukem*/#ifdef PICASSO96void DX_Invalidate (int first, int last){    if (first > last)	return;    picasso_has_invalid_lines = 1;    if (first < picasso_invalid_start)	picasso_invalid_start = first;    if (last > picasso_invalid_stop)	picasso_invalid_stop = last;    while (first <= last) {	picasso_invalid_lines[first] = 1;	first++;    } }int DX_BitsPerCannon (void){    return 8;}void DX_WaitVerticalSync( void ){//    IDirectDraw_WaitForVerticalBlank( lpDD, DDWAITVB_BLOCKBEGIN, NULL );}void DX_SetPalette(int start, int count){    if (! screen_is_picasso || picasso96_state.RGBFormat != RGBFB_CHUNKY)	return;    if (picasso_vidinfo.pixbytes != 1) {		/* This is the case when we're emulating a 256 color display.  */		while (count-- > 0) {			int r = picasso96_state.CLUT[start].Red;			int g = picasso96_state.CLUT[start].Green;			int b = picasso96_state.CLUT[start].Blue;			// And If I don't have an 16bit screen ???			// here is the BROKEN stuff for 32 bit mode : !BUG!			picasso_vidinfo.clut[start++] = (doMask256 (r, 5/*red_bits*/, 10/*red_shift*/)							| doMask256 (g, 5/*green_bits*/, 5/*green_shift*/)							| doMask256 (b, 5/*blue_bits*/, 0/*blue_shift*/));			}		return;		}    while (count-- > 0) {		my_setpalette(start, picasso96_state.CLUT[start].Red * 63 / 255,				picasso96_state.CLUT[start].Green * 63 / 255,				picasso96_state.CLUT[start].Blue * 63 / 255);		start++;		}}#define MAX_SCREEN_MODES 11static int x_size_table[MAX_SCREEN_MODES] = { 320, 320, 320, 320, 640, 640, 640, 800, 1024, 1152, 1280 };static int y_size_table[MAX_SCREEN_MODES] = { 200, 240, 256, 400, 350, 480, 512, 600, 768, 864, 1024 };int DX_FillResolutions (uae_u16 *ppixel_format){	int i,j, count = 0;	int w, h;    int maxw = 0, maxh = 0;	int emulate_chunky = 0;	w=(*curDevice)->gdRect.right-(*curDevice)->gdRect.left;	h=(*curDevice)->gdRect.bottom-(*curDevice)->gdRect.top;	picasso_vidinfo.rgbformat = (bit_unit == 8 ? RGBFB_CHUNKY					: bit_unit == 16 ? RGBFB_R5G5B5					: bit_unit == 32 ? RGBFB_A8R8G8B8					: RGBFB_NONE);						*ppixel_format = 1 << picasso_vidinfo.rgbformat;		//if (bit_unit == 16 || bit_unit == 32)	if (bit_unit == 16 )	// 8bit emulation on a 32 bit screen is currently							// broken : see dx_set_pallette	*ppixel_format |= RGBFF_CHUNKY, emulate_chunky = 1;    for (i = 0; i < MAX_SCREEN_MODES && count < MAX_PICASSO_MODES ; i++) {//    	int j;	    for (j = 0; j <= emulate_chunky && count < MAX_PICASSO_MODES; j++) {			if (x_size_table[i] <= w && y_size_table[i] <= h) {	    		if (x_size_table[i] > maxw) maxw = x_size_table[i];	    		if (y_size_table[i] > maxh) maxh = y_size_table[i];	    		DisplayModes[count].res.width = x_size_table[i];	    		DisplayModes[count].res.height = y_size_table[i];	   			DisplayModes[count].depth = j == 1 ? 1 : bit_unit >> 3;			    DisplayModes[count].refresh = 75;			    count++;				}			}		}	return count;}void gfx_set_picasso_modeinfo (int w, int h, int depth,int rgbfmt){    picasso_vidinfo.width = w;    picasso_vidinfo.height = h;    picasso_vidinfo.depth = depth;    picasso_vidinfo.pixbytes = bit_unit >> 3;}void gfx_set_picasso_baseaddr (uaecptr a){}void gfx_set_picasso_state (int on){    if (on == screen_is_picasso)	return;    graphics_subshutdown ();    screen_is_picasso = on;    if (on) {	current_width = picasso_vidinfo.width;	current_height = picasso_vidinfo.height;    } else {	current_width = gfxvidinfo.width;	current_height = gfxvidinfo.height;    }    graphics_subinit ();    if (on)	DX_SetPalette (0, 256);}uae_u8 *gfx_lock_picasso (void){	return (uae_u8 *)p96addr;}void gfx_unlock_picasso (void){}static void P96_flush_block(const int start_y, const int end_y){		double *src,*dest;	 	double *unrollSrc, *unrollDest, unroll0, unroll1;	unsigned long x, y, len;	if (!screen_visible) return;	y=start_y;	do {		src=(double *)(p96addr+(y*picasso_vidinfo.rowbytes));		dest=(double *)(winbaseaddr+(y*winrowbytes));		unrollSrc = src-2; unrollDest = dest-2;		--src; --dest;		for (len=lenght>>1,x=0;x<len;++x)		{			unroll0 = *(src+=2); unroll1 = *(unrollSrc+=2);  			*(dest+=2) = unroll0; *(unrollDest+=2) = unroll1;		}	} while (y++ < end_y);}#endif /* PICASSO96 *//***************************************************************************/int main( void ){	short count;		MaxApplZone() ;	for (count=0; count<10; count++)	MoreMasters();	InitToolbox();//	COM_InitCommToolbox();	// TKR : !BUG!	SetEventMask(-1); /* I want KeyUpEvent */	my_check_config();		{		int argc=1;		char a1[]="uae";		char *argv[1];		argv[0]=a1;		real_main(argc, argv);	}//	COM_CloseCommToolbox();	// TKR : !BUG!	return 0;}/***************************************************************************/