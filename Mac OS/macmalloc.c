#if 1/** changes made by !ZAJC!/GDS (Marin Saric) can be found	by searching for "!ZAJC!". The number after "!ZAJC!"	indicates day,month and year when the change was made**/#include <stdio.h>#include <stdlib.h>#include <Memory.h>#include <Processes.h> /* !ZAJC! 090798 */#include <string.h>    /* !ZAJC! 090798 */// save 32k for a rainy day#define EXTRA_SIZE 32768// if we have less than 256k left in the application heap, start using system memory#define APP_HEAP_MIN (65536*4)#define TAG_ALLOC_VAL 0xfedc0123#define TAG_FREE_VAL 0xba984567// pointer to the rainy day memorystatic /*unsigned*/ char *extra;// structure describing a header before each block of memorytypedef struct MemoryHeader{	Handle handle;	unsigned long tag;} MemoryHeader;// pointer to the first block of memorystatic MemoryHeader *first;// malloc replacementvoid *malloc (size_t size){	MemoryHeader *memory = nil;	Handle handle = nil;		// keep an extra bit of memory around for emergencies	if (!extra)		extra = NewPtr (EXTRA_SIZE);		// allocate as a pointer if this won't take us under the minimum heap size	if (FreeMem () > APP_HEAP_MIN + size)		memory = (MemoryHeader *)NewPtr (size + sizeof (MemoryHeader));		// if we didn't succeed in the pointer department, try a handle	if (!memory)	{		OSErr err;		handle = TempNewHandle (size + sizeof (MemoryHeader), &err);		if (handle && err == noErr)		{			HLockHi (handle);			memory = (MemoryHeader *)*handle;		}	}		// handle a failure	if (!memory)	{		if (extra)			DisposePtr (extra);		printf ("Out of memory!");		ExitToShell ();	}		// fill in the header	memory->handle = handle;	memory->tag = TAG_ALLOC_VAL ^ (long)handle;		// return the result	return memory + 1;}// free replacementvoid free (void *data){	MemoryHeader *memory = (MemoryHeader *)data - 1;		// bail on a NULL	if (!data)		return;		// ensure this is a valid block	if (memory->tag != (TAG_ALLOC_VAL ^ (long)memory->handle))	{		if (memory->tag == TAG_FREE_VAL)			printf ("Error: double freeing a block of memory!");		else			printf ("Error: freeing an invalid block of memory!");		return;	}		// mark this block free	memory->tag = TAG_FREE_VAL;		// free the real pointer or handle	if (memory->handle)		DisposeHandle (memory->handle);	else		DisposePtr ((Ptr)memory);}// realloc replacementvoid *realloc (void *data, size_t size){	MemoryHeader *memory = (MemoryHeader *)data - 1;	void *newdata;	int oldsize;		// null data means a malloc	if (!data)		return malloc (size);		// null size means a free	if (!size)	{		free (data);		return nil;	}		// ensure this is a valid block	if (memory->tag != (TAG_ALLOC_VAL ^ (long)memory->handle))	{		if (memory->tag == TAG_FREE_VAL)			printf ("Error: reallocing an already-free block of memory!");		else			printf ("Error: reallocing an invalid block of memory!");		return NULL;	}		// what we do from here depends on the type of memory	if (memory->handle)	{		oldsize = GetHandleSize (memory->handle) - sizeof (MemoryHeader);		if (size <= oldsize)		{			HUnlock (memory->handle);			SetHandleSize (memory->handle, size + sizeof (MemoryHeader));			HLock (memory->handle);			return ((MemoryHeader *)*memory->handle) + 1;		}	}	else	{		oldsize = GetPtrSize ((Ptr)memory) - sizeof (MemoryHeader);		if (size <= oldsize)		{			SetPtrSize ((Ptr)memory, size + sizeof (MemoryHeader));			return data;		}	}		// if we get here, we have to be wasteful of memory	newdata = malloc (size);	BlockMoveData (data, newdata, oldsize);	free (data);	return newdata;}// calloc replacementvoid *calloc (size_t nmemb, size_t size){	void *data = malloc (nmemb * size);	if (data) memset (data, 0, nmemb * size);	return data;}#endif