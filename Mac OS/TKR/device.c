/***	File: device.c****	Inhalt: Routinen zur Bedienung der seriellen Schnittstelle.****	Autor: Christian Kaben**	Organisation: TKR GmbH & Co. KG, Kiel, Deutschland, Europa, Erde**	Datum Ersterstellung : 11.02.1998**	Datum letzte €nderung: 23.10.1998***/#include <ConnectionTools.h>#include <TerminalTools.h>#include <FileTransferTools.h>#include <CommResources.h>#include <CRMSerialDevices.h>#include "device.h"#include "serialtool.h"#include "my_memory.h"#include "utilities.h"#include "generic.h"#include <string.h>#include <stdio.h>ComStruct	ComHandle;void COM_ShowSerialPorts(void);/*****************************************************************/void COM_InitCommToolbox(void){	OSErr	error;	int		i;		// Allgemeine Initialisierung der CTB.	error = InitCRM();	error = InitCTBUtilities();	error = InitCM();	// Connection Manager.			// Weitere initialisierende Arbeiten.	ComHandle.connHandle = nil;	ComHandle.termHandle = nil;	ComHandle.ftHandle = nil;	for(i = 0;i < kMaxCOMPorts;i++)	{		ComHandle.comPort[i][0] = 0;	// LŠnge auf 0 setzen.	}	memset(&ComHandle.connConfig,0,sizeof(ConnConfig));			// Sucht das erste Tool in der Liste, meist das Apple Modem Modul.	(void)CRMGetIndToolName((OSType)classCM,1,ComHandle.connToolName);		// Setzt hiermit erst einmal einen gŸltigen Connection-Handle auf.//	error = COM_SetNewConnectionTool(&ComHandle,p2cstr(ComHandle.connToolName));error = COM_SetNewConnectionTool(&ComHandle,"Seriell Modul");if(error == -1)	// Dann gibt es das Modul nicht.{	error = COM_SetNewConnectionTool(&ComHandle,"Serial Tool");}		// Fragt die verfŸgbaren seriellen Ports ab.	COM_GetSerialPorts(&ComHandle);}/*****************************************************************/void COM_CloseCommToolbox(void){	COM_CloseConnection(&ComHandle.connHandle);}/*****************************************************************/OSErr COM_SetNewConnectionTool(void *theHandle, char *toolname){	OSErr	error = 0;	CMBufferSizes	sizes = { BUFFERSIZE_DATAIN, BUFFERSIZE_DATAOUT,							  BUFFERSIZE_CONTROLIN, BUFFERSIZE_CONTROLOUT,							  BUFFERSIZE_ATTENTIONIN, BUFFERSIZE_ATTENTIONOUT,							  BUFFERSIZE_RESERVEDIN, BUFFERSIZE_RESERVEDOUT };		COM_CloseConnection(((ComStruct *)theHandle)->connHandle);	((ComStruct *)theHandle)->connProcID = CMGetProcID(c2pstr(toolname));	if(((ComStruct *)theHandle)->connProcID != -1)	{		((ComStruct *)theHandle)->connHandle = 					CMNew(((ComStruct *)theHandle)->connProcID,cmData,sizes,0,0);	}	if( !((ComStruct *)theHandle)->connHandle )	{		error = -1;	}	return(error);}/*****************************************************************/void COM_CloseConnection(void *theHandle){	COM_Disconnect(theHandle);	if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		CMDispose(((ComStruct *)theHandle)->connHandle);		((ComStruct *)theHandle)->connHandle = nil;	}}/*****************************************************************/OSErr COM_SetConfig(void *theHandle, void **theConfig){	OSErr	error = noErr;		if(theHandle && theConfig && *theConfig)	{		memcpy(&((ComStruct *)theHandle)->connConfig,*theConfig,sizeof(ConnConfig));		*theConfig = (void *)((long)*theConfig + sizeof(ConnConfig));		memcpy(&((ComStruct *)theHandle)->termConfig,*theConfig,sizeof(TermConfig));		*theConfig = (void *)((long)*theConfig + sizeof(TermConfig));		memcpy(&((ComStruct *)theHandle)->ftConfig,*theConfig,sizeof(FTConfig));				if(((ComStruct *)theHandle)->connConfig.baudRate)		{			error = COM_SetBaudrate(theHandle,						((ComStruct *)theHandle)->connConfig.baudRate);		}		if(((ComStruct *)theHandle)->connConfig.dataBits)		{			error = COM_SetDatabits(theHandle,						((ComStruct *)theHandle)->connConfig.dataBits);		}		if(((ComStruct *)theHandle)->connConfig.handShake)		{			error = COM_SetHandshake(theHandle,						((ComStruct *)theHandle)->connConfig.handShake);		}		if(((ComStruct *)theHandle)->connConfig.parity)		{			error = COM_SetParity(theHandle,						((ComStruct *)theHandle)->connConfig.parity);		}		if(((ComStruct *)theHandle)->connConfig.stopBits)		{			error = COM_SetStopbits(theHandle,						((ComStruct *)theHandle)->connConfig.stopBits);		}		if(((ComStruct *)theHandle)->connConfig.comPort[0])		{			Str255	pStr;			char	*cStr;							pStr[0] = 0;			EasyAppendString(pStr,((ComStruct *)theHandle)->connConfig.comPort);			cStr = p2cstr(pStr);			error = COM_SetCOMPort(theHandle,cStr);		}	}		return(error);}/*****************************************************************//* Derzeit nur fŸr Serial Tool geeignet, spŠter aber einmal erweitern. */OSErr COM_SetBaudrate(void *theHandle, long baudRate){	OSErr			error       = noErr;	if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		error = SRT_SetBaudrate(((ComStruct *)theHandle)->connHandle,baudRate);		if(error == noErr)		{			((ComStruct *)theHandle)->connConfig.baudRate = baudRate;		}	}		return(error);}/*****************************************************************//* Derzeit nur fŸr Serial Tool geeignet, spŠter aber einmal erweitern. */OSErr COM_SetDatabits(void *theHandle, long dataBits){	OSErr			error       = noErr;	if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		error = SRT_SetDatabits(((ComStruct *)theHandle)->connHandle,dataBits);		if(error == noErr)		{			((ComStruct *)theHandle)->connConfig.dataBits = dataBits;		}	}		return(error);}/*****************************************************************//* Derzeit nur fŸr Serial Tool geeignet, spŠter aber einmal erweitern. */OSErr COM_SetHandshake(void *theHandle, long handShake){	OSErr			error       = noErr;	if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		error = SRT_SetHandshake(((ComStruct *)theHandle)->connHandle,handShake);		if(error == noErr)		{			((ComStruct *)theHandle)->connConfig.handShake = handShake;		}	}		return(error);}/*****************************************************************//* Derzeit nur fŸr Serial Tool geeignet, spŠter aber einmal erweitern. */OSErr COM_SetParity(void *theHandle, long parity){	OSErr			error       = noErr;	if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		error = SRT_SetParity(((ComStruct *)theHandle)->connHandle,parity);		if(error == noErr)		{			((ComStruct *)theHandle)->connConfig.parity = parity;		}	}		return(error);}/*****************************************************************//* Derzeit nur fŸr Serial Tool geeignet, spŠter aber einmal erweitern. */OSErr COM_SetStopbits(void *theHandle, long stopBits){	OSErr			error       = noErr;	if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		error = SRT_SetStopbits(((ComStruct *)theHandle)->connHandle,stopBits);		if(error == noErr)		{			((ComStruct *)theHandle)->connConfig.stopBits = stopBits;		}	}		return(error);}/*****************************************************************//* Derzeit nur fŸr Serial Tool geeignet, spŠter aber einmal erweitern. */OSErr COM_SetCOMPort(void *theHandle, char *portName){	OSErr			error       = noErr;	if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		error = SRT_SetPort(((ComStruct *)theHandle)->connHandle,portName);		if(error == noErr)		{			strcpy((char *)((ComStruct *)theHandle)->connConfig.comPort,portName);			(void)c2pstr((char *)((ComStruct *)theHandle)->connConfig.comPort);		}	}		return(error);}/*****************************************************************/void COM_GetSerialPorts(void *theHandle){	CRMRecPtr		theCRM;	CRMRec			theCRMRec;	CRMErr			theErr;	CRMSerialPtr	theSerial;	int				old;	int				count = 0;		theErr = 0;	old = 0;	while(theErr == noErr)	{		theCRMRec.crmDeviceType = crmSerialDevice;		theCRMRec.crmDeviceID = old;		theCRM = &theCRMRec;		theCRM = CRMSearch(theCRM);		if(theCRM != nil)		{			theSerial = (CRMSerialPtr)theCRM->crmAttributes;			old = theCRM->crmDeviceID;			{			StringPtr	devicename;						devicename = *theSerial->name;			if(count < kMaxCOMPorts)			{					// Name merken fŸr spŠtere Verwendung.				if(theHandle)				{					((ComStruct *)theHandle)->comPort[count][0] = 0;	// LŠnge auf 0 setzen.					EasyAppendString(((ComStruct *)theHandle)->comPort[count++],devicename);				}			}			}		}		else		{			theErr = -1;		}	}}int	connectCount = 0;/*****************************************************************/OSErr COM_Connect(void *theHandle){	CMErr			theErr = 1;	CMBufferSizes	sizes;	CMStatFlags		status;		if(theHandle && ((ComStruct *)theHandle)->connHandle)	{if(++connectCount > 1){	return(noErr);}		theErr = CMStatus(((ComStruct *)theHandle)->connHandle,sizes,&status);		if( !(status & (cmStatusOpen + cmStatusOpening)) )		{			if( !COM_AllocGetSerC(theHandle) )			{				theErr = CMOpen(((ComStruct *)theHandle)->connHandle,false,nil,-1);				if(theErr == noErr)				{				}			}			else			{				theErr = 2;			}		}		if(theErr)		{			(void)COM_Disconnect(theHandle);		}	}		return(theErr);}/*****************************************************************/OSErr COM_Disconnect(void *theHandle){	CMErr			theErr = 1;	CMBufferSizes	sizes;	CMStatFlags		status;		if(theHandle && ((ComStruct *)theHandle)->connHandle)	{if(--connectCount){	return(noErr);}		theErr = CMStatus(((ComStruct *)theHandle)->connHandle,sizes,&status);		if(status & (cmStatusOpen + cmStatusOpening))		{			theErr = CMClose(((ComStruct *)theHandle)->connHandle,false,nil,0,true);		}		COM_FreeGetSerC(theHandle);	}		return(theErr);}/*****************************************************************/long COM_SendData(void *theHandle, char *data, long size){	CMErr	theErr = 0;		if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		theErr = CMWrite(((ComStruct *)theHandle)->connHandle,data,&size,cmData,false,nil,0,0);	}		return(size);}/*****************************************************************/long COM_ReceiveData(void *theHandle, char *data, long size){	CMErr	theErr = 0;		if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		theErr = CMRead(((ComStruct *)theHandle)->connHandle,data,&size,cmData,false,nil,0,0);	}		return(size);}/***********************************************************************/long COM_AllocGetSerC(void *theHandle){	Handle	buffer = nil;	OSErr	error = 0;	if( !theHandle )	{		return(kNilHandleError);	}		memset(&((ComStruct *)theHandle)->getSerIn,0,sizeof(GetSerIn));	((ComStruct *)theHandle)->getSerIn.gs_bufsize = 32 * 1024L;	error = EasyAllocateHandle(				((ComStruct *)theHandle)->getSerIn.gs_bufsize, 				&((ComStruct *)theHandle)->getSerIn.gs_bufferhandle);	if (error)	{		return error;	}	/* lock it in memory, ignore return we're just going to dump it */	EasyLockHandle(((ComStruct *)theHandle)->getSerIn.gs_bufferhandle);	((ComStruct *)theHandle)->getSerIn.gs_data = 					*((ComStruct *)theHandle)->getSerIn.gs_bufferhandle;	if( !((ComStruct *)theHandle)->getSerIn.gs_data ) 					return(/*(FILE_NO << 16) + (ALLOCGETSERC_NO << 8) + 1*/1);	((ComStruct *)theHandle)->getSerIn.gs_bufptr = 					((ComStruct *)theHandle)->getSerIn.gs_data;	return(error);}  /* end of function allocgetserc() *//***********************************************************************/int COM_GetSerC(void *theHandle){	if( !theHandle ) return((int)-1);	if( !((ComStruct *)theHandle)->getSerIn.gs_bufferhandle) return((int)-1);		if(((ComStruct *)theHandle)->getSerIn.gs_buflen <= 0)	{		long	ioact;		((ComStruct *)theHandle)->getSerIn.gs_bufptr = 							((ComStruct *)theHandle)->getSerIn.gs_data;				ioact = COM_ReceiveData(theHandle,							((ComStruct *)theHandle)->getSerIn.gs_data,							((ComStruct *)theHandle)->getSerIn.gs_bufsize);		if(ioact)		{			((ComStruct *)theHandle)->getSerIn.gs_buflen += ioact;		}	}	if(((ComStruct *)theHandle)->getSerIn.gs_buflen > 0) {		unsigned char	c;		c = *((ComStruct *)theHandle)->getSerIn.gs_bufptr++;		((ComStruct *)theHandle)->getSerIn.gs_buflen--;		return((int)c);		}	return((int)-1);}  /* end of function getserc() *//***********************************************************************/void COM_FreeGetSerC(void *theHandle){	if(theHandle && ((ComStruct *)theHandle)->getSerIn.gs_bufferhandle)	{		EasyDisposeHandle(&((ComStruct *)theHandle)->getSerIn.gs_bufferhandle);	}	((ComStruct *)theHandle)->getSerIn.gs_bufferhandle = nil;}  /* end of function allocgetserc() *//***********************************************************************/long COM_GetCOMPortNames(Str255 **theCOMPortArray){	long	count = 0;	int		i;		for(i = 0;i < kMaxCOMPorts;i++)	{		if(ComHandle.comPort[i][0])		{			count++;		}		else		{			break;		}	}		*theCOMPortArray = ComHandle.comPort;		return(count);}/***********************************************************************/void *COM_GetComHandle(void){	return((void *)&ComHandle);}/*****************************************************************/OSErr COM_StatusIsSet(void *theHandle, long theBit){	Boolean			isSet = false;	CMBufferSizes	sizes;	CMStatFlags		status;		if(theHandle && ((ComStruct *)theHandle)->connHandle)	{		if( !CMStatus(((ComStruct *)theHandle)->connHandle,sizes,&status) )		{			if(theBit == COMFLG_STATUSCD)			{				if(status & cmStatusOpen)				{					isSet = true;				}			}			if(theBit == COMFLG_STATUSDSR)			{				isSet = true;			}		COM_FreeGetSerC(theHandle);		}	}		return(isSet);}