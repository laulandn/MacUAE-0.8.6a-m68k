/*****************************************************************//*	                       EasyApp		            The Macintosh Application Shell		            James E. Trudeau, Nebula, Inc.		With thanks to Eric Shapiro, Bill Worzel, Brad Mohr, Bill	Hofmann, and many more folks, including the fine people at	Apple's Developer Technical Support and Developer University.		Version 1.0  4/3/95*//*****************************************************************//*	memory.c contains utilities for managing memory*/#include	"my_memory.h"/********************************************************************/* Globals *//********************************************************************///extern EasyGlobal	g;/*****************************************************************//* EasyGetMoreMasters *//*****************************************************************//*	Allocate master pointer blocks. Do this before allocating any	memory, to avoid fragmenting the heap with non-relocatable blocks.	Requires: short value for number of desired master pointer blocks	Receives: nothing	Changes:  nothing in the app, allocates required blocks	Returns:  nothing*/void EasyGetMoreMasters (short numberMasterBlocks){	while (numberMasterBlocks >0)	{		MoreMasters();		numberMasterBlocks--;	}}/*****************************************************************//* EasyAllocateHandle *//*****************************************************************//*	Unified memory allocation for handles. Whenever possible, make	this call instead of calling NewHandle() directly. This will	ensure that all is well.	Requires: nothing	Receives: desired size, pointer to Handle to store results	Changes:  nothing	Returns:  error value*/OSErr	EasyAllocateHandle(long size, Handle *handleAddress){	OSErr	error = noErr;	/* preflight all memory requests */	error = EasyCheckMemory(size);	if (error)	{		*handleAddress = nil;		return error;	}		/* allocate handle */	*handleAddress = NewHandleClear(size);	if(!*handleAddress)	{		error = MemError();	}			return error;}/*****************************************************************//* EasyCheckMemory *//*****************************************************************//*	Preflight memory requests (i.e. make sure there's enough memory	before we go asking for large chunks. If we run out of room,	release the emergency reserve and warn user	Requires: nothing	Receives: number of bytes requested	Changes:  nothing	Returns:  error value, 0 => OK*/OSErr	EasyCheckMemory (long numberBytes){	OSErr	error = noErr;	long	totalSize, contigSize;/* see if we have enough room in memory */	PurgeSpace(&totalSize, &contigSize);	/* if a purge would result in the largest block being too small… */	if (contigSize < numberBytes)	{ //		if (g.memoryReserve)	/* we've got an emergency reserve *///		{//			/* release the reserve and try again *///			EasyDisposeHandle(&g.memoryReserve);//			ShowErrorHook(kReleaseMemoryError);//			error = EasyCheckMemory (numberBytes);	/* recursive call *///		}//		else	/* no reserve left *///		{			error = memFullErr;	/* so we're out of memory *///		}	}	return error;}/*****************************************************************//* EasyCheckMemoryReserve *//*****************************************************************//*	Release or restore the memory reserve at need.	Requires: nothing	Receives: nothing	Changes:  may release or allocate memory reserve	Returns:  nothing*/void EasyCheckMemoryReserve(void){//	if (g.memoryReserve)	/* we've got a reserve, see if we need to release it *///	{//		EasyCheckMemory(kMinimumMemory); /* ignore error *///	}////	else	/* we have already released it, see if we can recover it. *///	{//		EasyAllocateHandle (kMemoryReserveSize, &g.memoryReserve);////		/* ignore error, we already warned the user once *///	}}/*****************************************************************//* EasyDisposeHandle *//*****************************************************************//*	Dispose of a handle in all circumstances. Checks for nil handles	as well. Locked handled may be disposed. Locked simply means	they can't be moved, not that they can't be disposed.	Requires: nothing	Receives: address of a handle to relocatable block	Changes:  deallocates memory, sets handle to nil	Returns:  nothing*/void EasyDisposeHandle (Handle *handleAddress){	char	flags;	Handle	theHandle = *handleAddress;		if (theHandle)	/* never dispose of a nil handle */	{		/* is it a resource handle? */		flags = HGetState(theHandle);	/* get the handle flags */		if (flags & 0x0020)		/* it is a resource */		{			ReleaseResource(theHandle);	/* assumes resChanged not set */		}		else	/* not a resource */		{			DisposeHandle(theHandle);	/* not a resource, dispose of it */		}				/* set handle to nil for safety */		*handleAddress = nil;	}}/*****************************************************************//* EasyDisposePointer *//*****************************************************************//*	Dispose of a pointer in all circumstances. Checks for nil	pointers.	Requires: nothing	Receives: a pointer to a non-relocatable block	Changes:  deallocates memory	Returns:  nothing*/void EasyDisposePointer (Ptr p){	if (p)	/* never dispose of a nil pointer */	{		DisposePtr(p);	}}/*****************************************************************//* EasyLockHandle *//*****************************************************************//*	Lock a handle, always doing the right thing. Preserve the handle's	current state, then move it high and lock it. It is the caller's	responsibility to restore the handle's state.	Requires: nothing	Receives: handle to be locked, pointer to signed byte to store state	Changes:  contents of state, may move memory	Returns:  nothing*/SignedByte	EasyLockHandle (Handle h){	SignedByte	state;	/* get current state of handle so caller can restore it to original state */	state = HGetState(h);/* move it high in heap and lock it (redundant if already locked, but no problem) */	HLockHi(h);		return state;}